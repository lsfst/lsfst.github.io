{"meta":{"title":"Hello","subtitle":null,"description":null,"author":"LSF","url":"https://github.com/lsfst/lsfst.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-11-24T09:01:20.363Z","updated":"2018-11-24T09:01:20.363Z","comments":false,"path":"/404.html","permalink":"https://github.com/lsfst/lsfst.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-11-24T09:01:20.376Z","updated":"2018-11-24T09:01:20.376Z","comments":false,"path":"about/index.html","permalink":"https://github.com/lsfst/lsfst.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2018-11-24T09:01:20.376Z","updated":"2018-11-24T09:01:20.376Z","comments":false,"path":"books/index.html","permalink":"https://github.com/lsfst/lsfst.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-11-24T09:01:20.377Z","updated":"2018-11-24T09:01:20.377Z","comments":false,"path":"repository/index.html","permalink":"https://github.com/lsfst/lsfst.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-24T09:01:20.376Z","updated":"2018-11-24T09:01:20.376Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/lsfst/lsfst.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-11-24T09:01:20.377Z","updated":"2018-11-24T09:01:20.377Z","comments":true,"path":"links/index.html","permalink":"https://github.com/lsfst/lsfst.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-24T09:01:20.378Z","updated":"2018-11-24T09:01:20.378Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/lsfst/lsfst.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP轮询实现长连接","slug":"长轮询","date":"2019-04-19T16:00:00.000Z","updated":"2019-07-12T03:59:40.782Z","comments":true,"path":"2019/04/20/长轮询/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2019/04/20/长轮询/","excerpt":"","text":"需求&emsp;&emsp;最近手上在做的项目要求android终端设备与服务端保持连接，服务端不定期向客户端推送消息(验证码，指令等)，原定是用Netty写一个websocket服务器做的，但由于前期进度催的比较紧，并发量也不大，Netty相关的内容我也还在学习中，经过一番讨论后还是决定先使用HTTP长轮询接口代替，之后再进行扩展。HTTP轮训轮询：客户端定时向服务器发送HTTP请求，服务器接到请求后马上返回响应信息并关闭连接。 优点：后端程序编写比较容易。 缺点：请求中有大半是无用，浪费带宽和服务器资源。 实例：适于小型应用。 长轮询：客户端向服务器发送HTTP请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 优点：在无消息的情况下不会频繁的请求，耗费资源小。 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 实例：WebQQ、Hi网页版、Facebook IM。 &emsp;&emsp;简单轮询请求太过频繁了，业务中采用的长轮询来完成业务。既然存在并发要求和消息推送，服务端就不可能采用阻塞方法处理请求，只能采用异步线程处理请求了，具体来讲就是先hold住连接(默认30秒)，有新消息就推送过去，否则到期后返回一个默认结果。DeferredResult&emsp;&emsp;Spring提供了一个叫做DeferredResult的工具，将请求线程与后台执行线程分离，异步开来，它返回的时候实际结果可能没有生成，实际的结果可能会在另外的线程里面设置到DeferredResult中去。该类包含以下特性：超时配置：通过构造函数可以传入超时时间，单位为毫秒，也可以传入默认值，超时自动返回该默认结果；因为需要等待设置结果后才能继续处理并返回客户端，如果一直等待会导致客户端一直无响应， 因此必须有相应的超时机制来避免这个问题；实际上就算不设置这个超时时间，应用服务器或者Spring也会有一些默认的超时机制来处理这个问题。 结果设置：它的结果存储在一个名称为result的属性中；可以通过调用setResult的方法来设置属性；由于这个DeferredResult天生就是使用在多线程环境中的，因此对这个result属性的读写是有加锁的。 具体执行过程如下：1.客户端请求服务 2.SpringMVC调用Controller，Controller返回一个DeferredResult对象 3.SpringMVC调用ruquest.startAsync 4.DispatcherServlet以及Filters等从应用服务器线程中结束，但Response仍旧是打开状态，也就是说暂时还不返回给客户端 5.某些其它线程将结果设置到DeferredResult中，SpringMVC将请求发送给应用服务器继续处理 6.DispatcherServlet再次被调用并且继续处理DeferredResult中的结果，最终将其返回给客户端 请求容器&emsp;&emsp;为了便于随时设置DederredResult的值，需要将DederredResult使用一个并发容器收集起来，这里使用了google guava中的Multimap，多值map,对map进行了增强，一个key可以保持多个value。12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;23.0&lt;/version&gt;&lt;/dependency&gt;1private static Multimap&lt; String, DeferredResult&lt; Map &gt; &gt; requestsMap = Multimaps.synchronizedSetMultimap( HashMultimap.create() );消息容器&emsp;&emsp;由于存在着多种消息类型（验证码，升级版本，日志，cmd等），为了方便扩展直接使用Map或者SkipList存储消息；每次发布消息时，不是直接操作DeferredResult，而是先放进messageMap里面，通过定时任务定期取出messageMap里的数据设置回DeferredResult。1private static Map&lt; String, PoolingMessage &gt; messageMap = new ConcurrentSkipListMap&lt;&gt;();消息实体12345678910111213141516171819202122232425262728293031public class PoolingMessage &#123; private String vid; private long lastConnectime; private Map&lt;String,String&gt; message; public PoolingMessage( String vid)&#123; this(vid,&quot;&quot;,&quot;&quot;); &#125; public PoolingMessage( String vid, String type, String message)&#123; this.vid = vid; this.lastConnectime = System.currentTimeMillis(); this.message = new HashMap&lt;&gt;(); this.message.put( type,message ); &#125; public void setMessage( Map message ) &#123; this.message = message; &#125; public void setMessage( String type,String msg) &#123; if(this.message==null)&#123; this.message = new HashMap&lt;&gt;( ); &#125; this.message.put( type,msg ); &#125; ...&#125;&emsp;&emsp;话不多少，直接上代码了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124@Servicepublic class LongPoolingContainer &#123; private static Logger logger = LoggerFactory.getLogger( LongPoolingContainer.class ); private static Map&lt; String, PoolingMessage &gt; messageMap = new ConcurrentSkipListMap&lt;&gt;(); //定时轮询 private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(); private static Multimap&lt; String, DeferredResult&lt; Map &gt; &gt; requestsMap = Multimaps.synchronizedSetMultimap( HashMultimap.create() ); //SynchronizedMultimap 虽是并发容器，但多线程下遍历时进行修改还是会出现ConcurrentModificationException，需要对remove和遍历操作上锁 private ReentrantLock lock = new ReentrantLock(); //交给spring管理默认是单例，但还是得防止误操作启动多个轮询 private static AtomicBoolean isStarted = new AtomicBoolean(false); public static Map&lt; String, String &gt; default_result = new HashMap&lt; String, String &gt;() ; public LongPoolingContainer() &#123; if ( isStarted.compareAndSet(false,true) ) &#123; LongPollTask task = new LongPollTask(); executor.scheduleWithFixedDelay( task, 2, 1, TimeUnit.SECONDS ); &#125; &#125; public DeferredResult&lt; Map &gt; watch( String vid) &#123; DeferredResult&lt; Map &gt; deferredResult = new DeferredResult&lt;&gt;( ECConstants.LONG_POLL_TIMEOUT, default_result ); //当deferredResult完成时（不论是超时还是异常还是正常完成），移除requestsMap中相应的watch key deferredResult.onCompletion( () -&gt; &#123; lock.lock(); try &#123; logger.info( &quot;complete|result:&#123;&#125;&quot;, JSONObject.toJSONString( deferredResult.getResult() ) ); requestsMap.remove( vid, deferredResult ); &#125; finally &#123; lock.unlock(); &#125; &#125; ); lock.lock(); try &#123; requestsMap.put( vid, deferredResult ); &#125; finally &#123; lock.unlock(); &#125; return deferredResult; &#125; public void publish( String vid, Map&lt; String, String &gt; message ) &#123; if ( !StringUtils.isEmpty( message ) ) &#123; lock.lock(); try &#123; if ( requestsMap.containsKey( vid ) ) &#123; //清空对应消息 clear( vid ); //通知所有watch这个namespace变更的长轮询配置变更结果 Collection&lt; DeferredResult&lt; Map &gt; &gt; deferredResults = requestsMap.get( vid ); logger.info( &quot;&#123;&#125;|publish msg: [&#123;&#125;]&quot;, vid, JSONObject.toJSONString( message ) ); for ( DeferredResult&lt; Map &gt; deferredResult : deferredResults ) &#123; deferredResult.setResult( message ); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public void put( PoolingMessage message ) &#123; messageMap.put( message.getVid(), message ); &#125; public void del( String vid ) &#123; messageMap.remove( vid ); &#125; public String getMsg( String vid, String type ) &#123; PoolingMessage message = messageMap.get( vid ); if ( message != null ) &#123; String msg = message.getMessage().get( type ); return msg; &#125; else &#123; return &quot;&quot;; &#125; &#125; public void setMsg( String vid, String msg ) &#123; setMsg( vid, &quot;CODE&quot;, msg ); &#125; public void setMsg( String vid, String type, String msg ) &#123; PoolingMessage message = messageMap.get( vid ); if ( message != null ) &#123; logger.info( vid + &quot;|publish|&#123;&#125;|&#123;&#125;&quot;, type, msg ); message.setLastConnectime( System.currentTimeMillis() ); message.setMessage( type, msg ); put( message ); &#125; else &#123; put( new PoolingMessage( vid, type, msg ) ); &#125; &#125; public void clear( String vid ) &#123; PoolingMessage message = messageMap.get( vid ); if ( message != null ) &#123; message.setLastConnectime( System.currentTimeMillis() ); message.setMessage( null ); put( message ); &#125; &#125; private class LongPollTask implements Runnable &#123; @Override public void run() &#123; long now = System.currentTimeMillis(); for ( Map.Entry&lt; String, PoolingMessage &gt; entry : messageMap.entrySet() ) &#123; PoolingMessage message = entry.getValue(); if ( null == message || message.getLastConnectime() + ECConstants.VALID_TIME &lt; now ) &#123; logger.info( &quot;&#123;&#125;|invalidate remove&quot;, message.getVid() ); del( entry.getKey() ); &#125; else &#123; Map msg = entry.getValue().getMessage(); if ( msg != null &amp;&amp; msg.size() &gt; 0 ) &#123; publish( entry.getKey(), msg ); &#125; &#125; &#125; &#125; &#125;&#125;源码地址","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"},{"name":"长连接","slug":"长连接","permalink":"https://github.com/lsfst/lsfst.github.io/tags/长连接/"},{"name":"并发","slug":"并发","permalink":"https://github.com/lsfst/lsfst.github.io/tags/并发/"}]},{"title":"仿照Redis实现一个简单缓存（二）","slug":"手写缓存(2)","date":"2019-03-26T16:00:00.000Z","updated":"2019-07-12T08:36:18.686Z","comments":true,"path":"2019/03/27/手写缓存(2)/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2019/03/27/手写缓存(2)/","excerpt":"","text":"现在实现缓存清理功能 Redis缓存清理策略&emsp;&emsp;Redis提供了以下三种过期键删除策略，其中第一种和第三种是主动删除策略，第二种为被动删除策略：定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即删除对键的删除操作。 惰性删除：放任键过期不管，但每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键。如果没有过期，就返回该键。 定期删除：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及检查多少数据库，由算法决定。 1 定时删除特点 优点：对内存友好，通过定时器可以保证过期键过期键会尽可能快的删除，并释放过期键占用的空间。 缺点：1）cpu不友好，在过期键比较多的情况下，删除过期键可能会占用相当一部分cpu时间；在内存不紧张cpu紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，无疑会对服务器响应时间和吞吐量造成影响。2）创建定时器需要Redis服务器中的时间事件，而现在时间事件的实现方式是无序链表，查找一个事件的时间复杂度为O(N)，并不能高效的处理大量时间事件。 2 惰性删除特点 优点：1）对cpu友好，程序只在取出键时才对建进行过期检查，删除的目标仅限于当前处理的键。 缺点：1）对内存不友好，当数据库中有大量的过期键，而这些键又没有被访问到，那么他们也许会永远不会被删除。 3 定期删除：是前两种删除策略的一种折中。会每隔一段时间执行一次删除过期键操作，并通过限制操作执行的时长和频率来减少删除操作对cpu时间的影响。 难点：确定删除策略的时长和频率 1）如果删除操作太过频繁，或者执行时间太长，定期删除策略就会退化成定时删除策略。 2）如果删除执行得太少，或者执行时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存现象。 &emsp;&emsp;实际上，Redis服务器使用的是惰性删除和定期删除两种策略：通过配合使用这两种策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。惰性删除其实很简单，所有读写Redis数据库的命令在执行之前都会调用expireIfNeeded函数对输入键进行检查，如果输入键过期，则删除输入键。但是这么做在多线程下是有问题的，所以要么加锁，要么仿照Redis采用单线程执行任务，既然这里都使用了并发容器，当然是选择加锁了。123456789101112private final ReentrantLock lock = new ReentrantLock();public void expireIfNeed(A arg)&#123; lock.lock(); try &#123; if(expired(arg))&#123; cache.remove(arg); expires.remove(arg) &#125; &#125;finally &#123; lock.unlock(); &#125;&#125;定时删除Redis服务器是一个事件驱动程序，服务器中的事件分成两类，一类是文件事件(服务器与客户端或其他服务器通过套接字连接通信产生的事件的抽象)，一类是时间事件，服务器需要定期对自身的资源和状态进行检查和调整，这些操作由serverCron函数负责执行，其中就包括过期键的清理。默认情况下，serverCron每秒运行10次，平均100ms运行一次。这个比较好实现，执行一个定时任务即可：1234567891011121314Eprivate final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(); private class ServerCron implements Runnable &#123; @Override public void run() &#123; for ( Map.Entry&lt; A, Long&gt; entry : expires.entrySet() ) &#123; Long expireTime = entry.getValue(); if ( expireTime &gt; System.currentTimeMillis() ) &#123; del( entry.getKey() ); &#125; &#125; &#125; &#125;&emsp;&emsp;这样就实现了基本功能了，当然向setnx，事务以及更复杂的功能是不支持的（逃完整代码","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"},{"name":"redis","slug":"redis","permalink":"https://github.com/lsfst/lsfst.github.io/tags/redis/"}]},{"title":"仿照Redis实现一个简单缓存（一）","slug":"手写缓存(1)","date":"2019-03-25T16:00:00.000Z","updated":"2019-07-12T07:14:45.539Z","comments":true,"path":"2019/03/26/手写缓存(1)/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2019/03/26/手写缓存(1)/","excerpt":"","text":"仿照Redis写一个简单的缓存，尽可能多的实现get，set，del，expire，ttl等功能。 Redis是K-V数据库，本质上就是一个大的字典表，所以大部分功能可以直接使用HashMap完成。 计算value&emsp;&emsp;由于获取value的方式可能有多种，需要先定义计算获取value的接口123public interface Computable&lt;A,V&gt; &#123; V get(A arg) throws InterruptedException;&#125;&emsp;&emsp;使用ConcurrentHashMap作为缓存结构；为了防止高并发下出现一个任务多次执行的情况，使用Future作为缓存value，获取值时直接调用future.get()返回结果,并采用putIfAbsent操作保证添加任务的原子性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Memoizer&lt;A,V&gt; implements Computable&lt;A,V&gt; &#123; private final Map&lt;A,Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;A,V&gt; c; public Memoizer(Computable&lt;A, V&gt; c) &#123; this.c = c; &#125; public void set(A arg)&#123; Future&lt;V&gt; f = cache.get(arg); if(f == null)&#123; cache.putIfAbsent(arg,new FutureTask&lt;&gt;(new Callable&lt;V&gt;() &#123; @Override public V call() throws Exception &#123; return c.compute(arg); &#125; &#125;)); &#125; &#125; //get自动实现了set功能 @Override public V get(A arg) throws InterruptedException &#123; while (true)&#123; Future&lt;V&gt; f = cache.get(arg); if(f == null)&#123; Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123; @Override public V call() throws Exception &#123; return c.get(arg); &#125; &#125;; FutureTask&lt;V&gt; ft = new FutureTask&lt;&gt;(eval); f = cache.putIfAbsent(arg,ft); //f为null说明没有这个任务 if(f == null)&#123; f = ft; ft.run(); &#125; &#125; try &#123; return f.get(); &#125; catch (CancellationException e) &#123; //缓存的是future时，会导致缓存污染，若任务被取消，需要移除任务 cache.remove(arg,f); &#125;catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void del(A arg)&#123; cache.remove(arg); &#125;&#125;增删查改操作完成了，同时解决了并发问题，接下来实现缓存逾期和自动清理功能。缓存逾期&emsp;&emsp;在Redis中有四个命令可以设置键的生存时间，过了这段时间，该键就会自动被删除：1234EXPIRE key ttl(单位秒)PEXPIRE key ttl(单位毫秒)EXPIREAT key timestamp(秒数时间戳)PEXPIREAT key timestamp(毫秒数时间戳)&emsp;&emsp;虽然说有多种不同单位和形式的设置命令，但前面三个本质上都是使用PEXIPIREAT命令来实现的：无论客户端执行的是上面哪一个，经过转换之后，最终的执行效果都和执行EXPIREAT命令一样伪代码：1234567891011121314151617181920//EXPIRE转成PEXPIREdef EXPIRE(key,ttl_in_sec)&#123; //将ttl转成毫秒 ttl_in_ms = sec_to_ms(ttl_in_sec) PEXPIRE(key,ttl_in_ms);&#125;//PEXPIRE转成PEXPIREATdef PEXPIRE(key,ttl_in_ms)&#123; now_ms = get_current_unix_timestamp_in_ms() PEXPIREAT(key,now_ms+ttl_in_ms);&#125; //EXPIREAT转成PEXPIREATdef EXPIREAT(key,expire_time_in_sec)&#123; expire_time_in_ms = sec_to_ms(expire_time_in_sec) PEXPIREAT(key,expire_time_in_ms)&#125;&emsp;&emsp;Redis内部专门使用一个expires字典表来保存数据库中所有键的过期时间，我们称这个字典表为过期字典：过期字典的key是一个指针，指向键空间中的某个键对象；过期字典的value是一个long long类型整数，记录键的过期时间———一个毫秒精度的UNIX时间戳&emsp;&emsp;expire的伪代码实现：12345678def PEXPIREAT(key,expire_time_in_ms)&#123; //检查key是否存在 if key not in redisDb.dict: return 0 //在过期字典设置过期时间 redisDb.expires[key] = expire_time_in_ms return 1 &#125;&emsp;&emsp;与之相对的PERSIST移除过期时间1234567def PERSIST(key)&#123; if key not in redisDb.expires: return 0 redisDb.expires.remove(key) return 1&#125;&emsp;&emsp;计算剩余存活时间的TTL和PTTL12345678910111213141516171819202122def PTTL(key)&#123; if key not in redisDb.dict: return -2 expire_time_in_ms = redisDb.expires.get(key) if expire_time_in_ms is None: return -1 now_ms = get_current_unix_timestamp_in_ms() return (expire_time_in_ms - now_ms)&#125;def TTL(key)&#123; ttl_in_ms = PTTL(key) if(ttl_in_ms&lt;0): return ttl_in_ms else: return ms_to_sec(ttl_in_ms)&#125;&emsp;&emsp;过期键判定EXPIRED：检查给定键是否存在于过期词典，存在则获取过期时间；检查当前UNIX时间戳是否大于键的过期时间，大于则过期12345678910111213def EXPIRED(key)&#123; expire_time_in_ms = redisDb.expires.get(key) if expire_time_in_ms is None: return False now_ms = get_current_unix_timestamp_in_ms() if now_ms&gt;expire_time_in_ms: return True else: return False&#125;&emsp;&emsp;Java实现如下12345678910111213141516171819202122232425262728293031323334353637383940414243//过期时间表private final Map&lt;A,Long&gt; expires = new ConcurrentHashMap&lt;&gt;();public void expire(A arg ,int seconds)&#123; long now = System.currentTimeMillis(); expireAt(arg,now+seconds*1000);&#125;public void pexpire(A arg,int ms)&#123; long now = System.currentTimeMillis(); pexpireAt(arg,now+ms);&#125;public void expireAt(A arg,long timestamp)&#123; pexpireAt(arg,timestamp*1000);&#125;public void pexpireAt(A arg,long timestamp)&#123; expires.put(arg,timestamp);&#125;public boolean expired(A arg)&#123; if(!expires.containsKey(arg))&#123; return false; &#125; return expires.get(arg)&lt;System.currentTimeMillis();&#125;public long ttl(A arg)&#123; long ttl_ms = pttl(arg); return ttl_ms&gt;0?ttl_ms/1000:ttl_ms;&#125;public long pttl(A arg)&#123; if(!cache.containsKey(arg))&#123; return -2; &#125; if(!expires.containsKey(arg))&#123; return -1; &#125; return expires.get(arg) - System.currentTimeMillis();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"},{"name":"redis","slug":"redis","permalink":"https://github.com/lsfst/lsfst.github.io/tags/redis/"}]},{"title":"Apache Guacamole 使用记录","slug":"guacamole","date":"2019-03-16T16:00:00.000Z","updated":"2019-07-12T03:52:27.970Z","comments":true,"path":"2019/03/17/guacamole/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2019/03/17/guacamole/","excerpt":"","text":"简介&emsp;&emsp;Guacamole是由多个模块组成的无客户端的远程桌面网关，它支持VNC,RDP,SSH等标准协议。guacamole包括两大部分，guacamole-client和guacamole-server。client是一个web服务器，实现了对server的远程访问。server则实现了client和远程桌面服务的桥梁。用户通过浏览器连接到Guacamole的服务端。Guacamole的客户端是用JavaScript编写的，Guacamole server通过web容器（比如tomcat）把服务提供给用户。一旦加载，客户端通过http承载着Guacamole自己的定义的协议与服务端通信。部署在Guacamole server这边的Web应用程序，解析到Guacamole protocal，就传给Guacamole的代理guacd（中间层），这个代理替用户连接到远程机器。安装流程下载地址官方文档操作系统:CENTSOS 6.9+tomcat8+jdk8客户端可以直接下载war包在tomcat使用，但服务端必须要下载源码在本地编译.没时间解释了，具体流程参考文档tomcat安装yum install tomcat安装GCC编译环境yum install gcc安装依赖yum -y install cairo-devel libjpeg-devel libpng-devel uuid-develyum -y install ffmpeg-devel freerdp-devel pango-devel libssh2-develyum -y install libtelnet-devel libvncserver-devel pulseaudio-libs-develyum -y install openssl-devel libvorbis-devel libwebp-develyum -y install freerdp-plugins下载服务端压缩包tar -xzvf guacamole-server-0.9.14.tar.gz进入解压目录cd /guacamole-server-0.9.14/编译,如果检测状态含有no，需要检查上方的第三方库是否安装正确。./configure –with-init-dir=/etc/init.d安装makemake install启动guacd服务/etc/init.d/guacd start客户端直接将war包放在/var/lib/tomcat/webapps目录下,重启tomcat/etc/init.d/tomcat restart访问http://ip:8080/guacamole这时候能看到页面，但还不能登陆，还需要配置默认情况下，Guacamole的默认配置目录在linux下是/etc/guacamole，在windows下则是C:\\Users\\curentUser.guacamole,需要在对应位置手动创建.guacamole这个目录在该目录下新建guacamole.properties，这是主要的Guacamole配置文件。该文件中的属性规定了Guacamole将如何连接到guacd。在文件中写入：12guacd-hostname:localhostguacd-port:4822新建user-mapping.xml 写入12345678&lt;user-mapping&gt; &lt;authorize username=&quot;test&quot; password=&quot;test&quot;&gt; &lt;protocol&gt;vnc&lt;/protocol&gt; &lt;param name=&quot;hostname&quot;&gt;192.168.162.15&lt;/param&gt; &lt;param name=&quot;port&quot;&gt;5900&lt;/param&gt; &lt;/authorize&gt;&lt;/user-mapping&gt; 这里是说，新增一个vnc服务器，服务器地址为192.168.162.15，vnc所有端口为5900，guacamole连接这个vnc服务器的用户名和密码为test，test。如果想配置多个连接，就写多个authorize节点。最后在服务器上搭建好VNC服务就可以在客户端进行访问了。","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"}]},{"title":"缓存穿透与缓存击穿问题","slug":"缓存击穿与穿透","date":"2019-01-16T16:00:00.000Z","updated":"2019-07-12T04:05:46.473Z","comments":true,"path":"2019/01/17/缓存击穿与穿透/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2019/01/17/缓存击穿与穿透/","excerpt":"","text":"缓存穿透缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。布隆过滤器&emsp;&emsp;采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。1234567891011121314151617private static BloomFilter&lt;Integer&gt; bloomFilter =BloomFilter.create(Funnels.integerFunnel(), size)&#123; //添加所有存在的key bloomFilter.put(allKeys); &#125;; String get(String key) &#123; String value = redis.get(key); if (value == null) &#123; if(!bloomfilter.mightContain(key))&#123; return null; &#125;else&#123; value = db.get(key); redis.set(key, value); &#125; &#125; return value；&#125;&emsp;&emsp;优点是思路简单,保证一致性,性能强；缺点是代码复杂度增大,需要另外维护一个集合来存放缓存的Key,且布隆过滤器不支持删值操作。缓存空值另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），把这个空结果进行缓存，并设置一个较短的过期时间，防止占有太多内存空间。缓存击穿&emsp;&emsp;对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。&emsp;&emsp;缓存击穿本质上是并发问题。1.互斥锁&emsp;&emsp;缓存失效的时候（判断拿出来的值为空），不是立即去查询数据库，而是先获取互斥锁（单机直接加锁，分布式则使用Redis的SETNX，Zookeeper的Znode等），当操作返回成功时，再查询数据库并回设缓存；否则，就重试整个get缓存的方法。1234567891011121314151617public String get(key) &#123; String value = redis.get(key); if (value == null) &#123; //设置过期时间，防止del操作失败 if (redis.setnx(key_mutex, 1, 60) == 1) &#123; value = db.get(key); redis.set(key, value, expire_secs); redis.del(key_mutex); &#125; else &#123; sleep(50); get(key); //重试 &#125; &#125; else &#123; return value; &#125; &#125; redis发布订阅模式&emsp;&emsp;实际上redis本身也提供了的类似MQ的简单发布订阅模式，结合Spring使用起来非常简单，但是仔细看过文档后，发现这个功能还是有所不足。&emsp;&emsp;redis的发布订阅与主流的消息队列中间件比较：（1）主流的消息队列如RabbitMQ,ActiveMQ等支持多种消息协议，包括AMQP，MQTT，Stomp等，并且支持JMS规范，但Redis没有提供对这些协议的支持； （2）消息队列提供持久化功能，但Redis无法对消息持久化存储，一旦消息被发送，如果没有订阅者接收，那么消息就会丢失； （3）消息队列提供了消息传输保障(发布-接收确认和事务)，当客户端连接超时或事务回滚等情况发生时，消息会被重新发送给客户端，Redis没有提供消息传输保障。 &emsp;&emsp;其中最大的缺点是消息没有持久化，没有传输保障，无法保证客户端能对消息进行消费，所以这个方案也就只能pass了。","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"},{"name":"redis","slug":"redis","permalink":"https://github.com/lsfst/lsfst.github.io/tags/redis/"}]},{"title":"类加载原理与getResourceAsStream","slug":"getResource","date":"2019-01-04T16:00:00.000Z","updated":"2019-03-31T15:24:53.315Z","comments":true,"path":"2019/01/05/getResource/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2019/01/05/getResource/","excerpt":"","text":"&emsp;&emsp;在项目启动时加载数据库脚本初始化数据库，采用getResourceAsStream去加载脚本，结果报错找不到对应文件。1234567891011121314 ... InputStream sqlFileIn = null; sqlFileIn = SqliteUtil.class.getResourceAsStream( \"/init.sql\" ); StringBuffer sqlSb = new StringBuffer(); byte[] buff = new byte[ 1024 ]; int byteRead = 0;while ( ( byteRead = sqlFileIn.read( buff ) ) != -1 ) &#123; sqlSb.append( new String( buff, 0, byteRead, \"utf-8\" ) );&#125; sqlFileIn.close(); ... &emsp;&emsp;没有办法，只能从getResourceAsStream的源码看起，一点一点找出结果。getResourceAsStream1234567891011public InputStream getResourceAsStream(String name) &#123; //先对资源路径解析 name = resolveName(name); ClassLoader cl = getClassLoader0(); if (cl==null) &#123; // A system class. return ClassLoader.getSystemResourceAsStream(name); &#125; //调用的getResource方法 return cl.getResourceAsStream(name);&#125;&emsp;&emsp;Class类的getResourceAsStream方法优先委托当前Class的classLoader去加载资源文件，如果当前类的classLoader为null，则调用ClassLoader的getSystemResourceAsStream加载1234567891011121314151617181920212223/** * Add a package name prefix if the name is not absolute,Remove leading \"/\" if name is absolute */private String resolveName(String name) &#123; if (name == null) &#123; return name; &#125; if (!name.startsWith(\"/\")) &#123; Class&lt;?&gt; c = this; while (c.isArray()) &#123; c = c.getComponentType(); &#125; String baseName = c.getName(); int index = baseName.lastIndexOf('.'); if (index != -1) &#123; name = baseName.substring(0, index).replace('.', '/') +\"/\"+name; &#125; &#125; else &#123; name = name.substring(1); &#125; return name;&#125;&emsp;&emsp;这里getResourceAsStream需要调用resolveName()解析资源路径：如果文件名以/开头，则移除前面的/，如果不以/开头，说明是相对路径，则在前面补充上其所在包名。这里是关键，很明显我的路径”/init.sql”是有问题的，系统会在当前类同级目录下寻找init.sql文件，但我的文件没放在这，所以报错。&emsp;&emsp;再看看ClassLoader的getSystemResourceAsStream，这个方法优先通过系统指定类加载器加载资源，又引出了getSystemClassLoader方法12345678910111213141516171819202122232425262728293031public static InputStream getSystemResourceAsStream(String name) &#123; URL url = getSystemResource(name); try &#123; return url != null ? url.openStream() : null; &#125; catch (IOException e) &#123; return null; &#125;&#125;public static URL getSystemResource(String name) &#123; //获取system classLoader ，也即 AppClassloader ClassLoader system = getSystemClassLoader(); if (system == null) &#123; //获取不到则通过BootStrapClassLoader加载资源 return getBootstrapResource(name); &#125; return system.getResource(name);&#125;public URL getResource(String name) &#123; URL url; if (parent != null) &#123; url = parent.getResource(name); &#125; else &#123; url = getBootstrapResource(name); &#125; if (url == null) &#123; url = findResource(name); &#125; return url;&#125;getSystemClassLoader在ClassLoader类中getSystemClassLoader方法调用私有的initSystemClassLoader方法获得AppClassloader实例：123456789101112131415161718192021222324252627282930313233343536373839404142public static ClassLoader getSystemClassLoader() &#123; initSystemClassLoader(); if (scl == null) &#123; return null; &#125; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkClassLoaderPermission(scl, Reflection.getCallerClass()); &#125; return scl;&#125;private static synchronized void initSystemClassLoader() &#123; if (!sclSet) &#123; if (scl != null) throw new IllegalStateException(\"recursive invocation\"); sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); if (l != null) &#123; Throwable oops = null; // scl = l.getClassLoader(); try &#123; scl = AccessController.doPrivileged( new SystemClassLoaderAction(scl)); &#125; catch (PrivilegedActionException pae) &#123; oops = pae.getCause(); if (oops instanceof InvocationTargetException) &#123; oops = oops.getCause(); &#125; &#125; if (oops != null) &#123; if (oops instanceof Error) &#123; throw (Error) oops; &#125; else &#123; // wrap the exception throw new Error(oops); &#125; &#125; &#125; sclSet = true; &#125;&#125;&emsp;&emsp;sun.misc.Launcher是jre中用于启动程序入口main()的类。Launcher类在new自己的时候生成AppClassloader实例并且放在自己的私有变量loader里。Launcher12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Launcher &#123; ... //私有classLoader private ClassLoader loader; public static Launcher getLauncher() &#123; return launcher; &#125; //公有构造 public Launcher() &#123; //创建扩展类加载器：ExtClassLoader是Launcher的内部类，继承自URLClassLoader Launcher.ExtClassLoader var1; try &#123; var1 = Launcher.ExtClassLoader.getExtClassLoader(); &#125; catch (IOException var10) &#123; throw new InternalError(\"Could not create extension class loader\", var10); &#125; try &#123; //创建用于启动应用程序的类加载器 this.loader = Launcher.AppClassLoader.getAppClassLoader(var1); &#125; catch (IOException var9) &#123; throw new InternalError(\"Could not create application class loader\", var9); &#125; //每个线程持有一个ContextClassLoader，可以用get,set方法获取或定义。如果不加指定，就是启动线程那个类自己的类加载器。如果不是main线程，new出来的线程的话，就是父线程的类加载器 Thread.currentThread().setContextClassLoader(this.loader); String var2 = System.getProperty(\"java.security.manager\"); if (var2 != null) &#123; //根据需求创建安全管理器：SecurityManager实例 SecurityManager var3 = null; if (!\"\".equals(var2) &amp;&amp; !\"default\".equals(var2)) &#123; try &#123; var3 = (SecurityManager)this.loader.loadClass(var2).newInstance(); &#125; catch (IllegalAccessException var5) &#123; &#125; catch (InstantiationException var6) &#123; &#125; catch (ClassNotFoundException var7) &#123; &#125; catch (ClassCastException var8) &#123; &#125; &#125; else &#123; var3 = new SecurityManager(); &#125; if (var3 == null) &#123; throw new InternalError(\"Could not create SecurityManager: \" + var2); &#125; System.setSecurityManager(var3); &#125; &#125; ...&#125;也就是说launcher初始化时做了以下工作：1.创建扩展类加载器ExtClassLoader2.创建用于启动应用程序的类加载器AppClassLoader3.设置当前线程的上下文类加载器为前一步创建的AppClassLoader实例4.创建安全管理器SecurityManager&emsp;&emsp;Launcher类使用了一种类似单例模式的方法，既提供了单例模式的接口getLauncher()又把构造函数设成了public的。但是在ClassLoader中是通过单例模式取得的Launcher 实例的，所以我们写的每个类加载器得到的AppClassloader都是同一个AppClassloader类实例，也就是说所有通过正常双亲委派模式的类加载器加载的classpath下的和ext下的所有类在方法区都是同一个类，堆中的Class实例也是同一个。ExtClassLoader12345678910111213141516171819202122232425262728293031static class ExtClassLoader extends URLClassLoader &#123; public static Launcher.ExtClassLoader getExtClassLoader() throws IOException &#123; final File[] var0 = getExtDirs(); try &#123; return (Launcher.ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123; public Launcher.ExtClassLoader run() throws IOException &#123; int var1 = var0.length; for(int var2 = 0; var2 &lt; var1; ++var2) &#123; MetaIndex.registerDirectory(var0[var2]); &#125; return new Launcher.ExtClassLoader(var0); &#125; &#125;); &#125; catch (PrivilegedActionException var2) &#123; throw (IOException)var2.getException(); &#125; &#125; public ExtClassLoader(File[] var1) throws IOException &#123; //显示指定java.ext.dirs目录，可以通过参数Djava.ext.dirs=… 修改 super(getExtURLs(var1), (ClassLoader)null, Launcher.factory); SharedSecrets.getJavaNetAccess().getURLClassPath(this).initLookupCache(this); &#125; private static File[] getExtDirs() &#123; //ExtClassLoader加载目录 String var0 = System.getProperty(\"java.ext.dirs\"); ... &#125;&#125;&emsp;&emsp;ExtClassLoader加载java.ext.dirs目录下的文件，默认是jre安装目录/lib/ext，是一些JDK或JRE的可选择功能扩展包。AppClassLoader1234567891011121314static class AppClassLoader extends URLClassLoader &#123; ... public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException &#123; final String var1 = System.getProperty(\"java.class.path\"); final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1); return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123; public Launcher.AppClassLoader run() &#123; URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2); return new Launcher.AppClassLoader(var1x, var0); &#125; &#125;); &#125; ...&#125;&emsp;&emsp;可以看到这里取的是环境变量java.class.path中设定的路径作为类加载的搜索路径。可以通过对该变量的设定来修改默认配置。classpath是指 WEB-INF文件夹下的classes目录 ，所有src目录下面的java、xml、properties等文件编译后都会在此，所以在开发时常将相应的xml配置文件放于src或其子目录下。类加载器总结&emsp;&emsp;Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自java.lang.ClassLoader。扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。&emsp;&emsp;除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。&emsp;&emsp;除了引导类加载器之外，所有的类加载器都有一个父类加载器。类加载采用委托模式，先一层一层交给父类加载，父加载不成功再一层一层转给子加载。&emsp;&emsp;要点1：为什么采用这种委托方式，是为了安全，比如用户自定义了个java.lang.String,那么如果不交给引导类加载器去加载的话，内存中就会有不止一个String的类实例。而且一个限定包内访问权限的内容，黑客也可以用这种方式获取（要点2再继续说明）。采用了这种方式的话，引导类加载器只会加载一次类，看见用户自定义的String来了，就去看自己有没有加载，结果是系统一启动就加载了java.lang.String类，就不会再去加载了。&emsp;&emsp;要点2：判断一个类是否相等不仅要看类是否名字一样，而且要看是否有同一个类初始化加载器。所以如果黑客要自己搞一个java.lang.Hack类来加载，由委托模式开始，引导类加载器加载这个类失败，那就只能交给用户自定义的类加载起来加载。所以这个类和系统的那个lang包里的类不在一个初始化加载器里，就算包名都一样，还是不能访问那些包内可见的内容的。&emsp;&emsp;进一步说明：有两个术语，一个叫“定义类加载器”，一个叫“初始类加载器”。比如有如下的类加载器结构：bootstrap ExtClassloader AppClassloader -自定义clsloadr1 -自定义clsloadr2 &emsp;&emsp;如果用“自定义clsloadr1”加载java.lang.String类，那么根据双亲委派最终bootstrap会加载此类，那么bootstrap类就叫做该类的“定义类加载器”，而包括bootstrap的所有得到该类class实例的类加载器都叫做“初始类加载器”。&emsp;&emsp;所说的“命名空间”，是指jvm为每个类加载器维护的一个“表”,这个表记录了所有以此类加载器为“初始类加载器”（而不是定义类加载器，所以一个类可以存在于很多的命名空间中）加载的类的列表。所以，对于String类来说，bootstrap是“定义类加载器”，AppClassloader是“初始类加载器”。根据刚才所说，String类在AppClassloader的命名空间中（同时也在bootstrap，ExtClassloader的命名空间中，因为bootstrap，ExtClassloader也是String的初始类加载器），所以在AppClassloader命名空间中的类可以随便访问String类。这样就可以解释“处在不同命名空间的类，不能直接互相访问”这句话了。&emsp;&emsp;一个类，由不同的类加载器实例加载的话，会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。&emsp;&emsp;由不同类加载器实例（比如-自定义clsloadr1，-自定义clsloadr2）所加载的classpath下和ext下的类，也就是由我们自定义的类加载器委派给AppClassloader和ExtClassloader加载的类，在内存中是同一个类吗？&emsp;&emsp;所有继承ClassLoader并且没有重写getSystemClassLoader方法的类加载器，通过getSystemClassLoader方法得到的AppClassloader都是同一个AppClassloader实例，类似单例模式。也就是所有通过正常双亲委派模式的类加载器加载的classpath下的和ext下的所有类在方法区都是同一个类，堆中的Class实例也是同一个。ContextClassLoader 每个线程持有一个ContextClassLoader，可以用get,set方法获取或定义。如果不加指定，就是启动线程那么类自己的类加载器。如果不是main线程，new出来的线程的话，就是父线程的类加载器。 为什么要有这么一个东西呢，因为为了安全ClassLoader的委托机制不能满足一些特定需要,这个时候就要用这种方式走后门。比如jdbc,jndi,tomcat等: Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers 包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。 线程上下文类加载器正好解决了这个问题。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。 总结了解了类加载机制后，那么前面getResourceAsStream的问题就好解决了，总结一下getResourceAsStream的用法：Class.getResourceAsStream(String path) ： path 不以’/‘开头时默认是从此类所在的包下取资源，以’/‘开头则是从 ClassPath根下获取。其只是通过path构造一个绝对路径，最终还是由ClassLoader获取资源。Class.getClassLoader.getResourceAsStream(String path) ： 默认则是从ClassPath根下获取，path不能以’/‘开头，最终是由 ClassLoader获取资源。ServletContext. getResourceAsStream(String path)： 默认从WebAPP根目录下取资源，Tomcat下path是否以’/‘开头无所谓，当然这和具体的容器实现有关。Jsp下的application内置对象就是上面的ServletContext的一种实现","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"}]},{"title":"Mybatis配置mysql+sqlite双数据源","slug":"MybatisSqliteMysql","date":"2019-01-04T16:00:00.000Z","updated":"2019-03-31T13:17:18.891Z","comments":true,"path":"2019/01/05/MybatisSqliteMysql/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2019/01/05/MybatisSqliteMysql/","excerpt":"","text":"需求&emsp;&emsp;目前需要对现有业务进行一次拆分，在项目里面配置两个数据源，要求权限，路由相关的数据在sqlite中操作，其他的数据在mysql中操作。sqlite是一款轻型的、嵌入式的关系型数据库，具体使用起来跟mysql大同小异。所以这实际上就是一个多数据源配置的问题，琢磨了好一会，算是找到了一种可行的方案。pom.xml&emsp;&emsp;话不多说，先引入依赖，主要是mybatis和jdbc连接包：12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.xerial&lt;/groupId&gt; &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt; &lt;version&gt;3.21.0.1&lt;/version&gt;&lt;/dependency&gt;配置123456789server.port=9090spring.datasource.mysql.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.mysql.jdbc-url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useSSL=falsespring.datasource.mysql.username=rootspring.datasource.mysql.password=myvifispring.datasource.sqlite.driver-class-name = org.sqlite.JDBCspring.datasource.sqlite.jdbc-url = jdbc:sqlite:sqlite.db其中要注意的点：1.配置单数据源时数据库配置不能用-隔开，会报错，使用spring.datasource.url 和spring.datasource.driverClassName即可；2.使用springboot2.0配置多数据源时需要-隔开：如spring.datasource.jdbc-url和spring.datasource.driver-class-name3.mysql-connector-java 6 以上版本必须指定时区serverTimezone,驱动使用com.mysql.cj.jdbc.Driver数据源mysql为主库,sqlite的代码就不贴来，与mysql大体一样，去掉@Primary注解，同时更换对应mapper目录即可12345678910111213141516171819202122232425262728293031@Configuration@MapperScan(basePackages = \"com.example.sqliteandmysql.mapper.test1\", sqlSessionTemplateRef = \"mysqlSqlSessionTemplate\")public class DataSource1Config &#123; @Bean(name = \"mysqlDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.mysql\") @Primary public DataSource testDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = \"mysqlSqlSessionFactory\") @Primary public SqlSessionFactory testSqlSessionFactory( @Qualifier(\"mysqlDataSource\") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mybatis/mapper/test1/*.xml\")); return bean.getObject(); &#125; @Bean(name = \"mysqlTransactionManager\") @Primary public DataSourceTransactionManager testTransactionManager( @Qualifier(\"mysqlDataSource\") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = \"mysqlSqlSessionTemplate\") @Primary public SqlSessionTemplate testSqlSessionTemplate( @Qualifier(\"mysqlSqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125;项目结构数据库初始化mysql1234567891011DROP TABLE IF EXISTS `users`;CREATE TABLE `users` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键id&apos;, `userName` varchar(32) DEFAULT NULL COMMENT &apos;用户名&apos;, `passWord` varchar(32) DEFAULT NULL COMMENT &apos;密码&apos;, `user_sex` varchar(32) DEFAULT NULL, `nick_name` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8;INSERT INTO users VALUES(1,&quot;李大姐&quot;,&quot;654321&quot;,&quot;WOMAN&quot;,&quot;李大姐mysql&quot;);sqlite1234567891011DROP TABLE IF EXISTS `users`;create table users( id int not null, passWord char(32), userName char(32), user_sex char(32), nick_name char(32));insert into users values (1,123456,&quot;张三&quot;,&quot;MAN&quot;,&quot;张麻子sqlite&quot;);顺便说说sqlite中的一些坑：&emsp;&emsp;1.sqlite自带自增row_id主键，所以不允许自定义自增主键。&emsp;&emsp;sqlite中每个表都默认包含一个隐藏列rowid(使用WITHOUT ROWID定义的表除外)。通常情况下，rowid可以唯一的标记表中的每个记录。表中插入的第一条记录的rowid为1，后续插入的记录的rowid由当前最大rowid+1得到。但默认的rowid不会持久化，比如：当所有记录被清空时，再插入记录时rowid会重新从1开始计数；也即每次插入数据设置rowid时，都会在当前已有的最大rowid的基础上+1，这一点与mysql的Integer AutoIncreament不同，mysql会跳过已经使用过的自增主键。&emsp;&emsp;所以如果要实现mysql那样的主键，需要声明WITHOUT ROWI放弃掉原生主键，同时指定新的主键，相当于是给rowid赋予了别名，同时实现了持久化。&emsp;&emsp;2.模糊类型带来的问题&emsp;&emsp;由于sqlite的数据类型比较模糊，所以从mysql迁移到sqlite时，javabean中的数据类型会发生微调，比如datetime会转化成String或者Integer，这一点需要在业务中进行处理。对应的实体类：123456789public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private Long id; private String userName; private String passWord; private UserSexEnum userSex; private String nickName; &#125; 对外接口1234567891011121314151617181920212223@RestControllerpublic class UserController &#123; @Autowired private User1Mapper user1Mapper; @Autowired private User2Mapper user2Mapper; @RequestMapping(&quot;/mysql/getUsers&quot;) public List&lt; User &gt; get1Users() &#123; List&lt;User&gt; users=user1Mapper.getAll(); return users; &#125; @RequestMapping(&quot;/sqlite/getUsers&quot;) public List&lt; User &gt; get2Users() &#123; List&lt;User&gt; users=user2Mapper.getAll(); return users; &#125;&#125; 测试结果","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"},{"name":"sqlite","slug":"sqlite","permalink":"https://github.com/lsfst/lsfst.github.io/tags/sqlite/"}]},{"title":"sqlite相关介绍","slug":"sqlite相关介绍","date":"2018-12-22T16:00:00.000Z","updated":"2019-03-12T17:08:30.079Z","comments":true,"path":"2018/12/23/sqlite相关介绍/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/12/23/sqlite相关介绍/","excerpt":"","text":"数据类型&emsp;&emsp;就大部分的增删查改操作而言，sqlite与mysql没多大区别。不过，与mysql不同的是，sqlite的数据类型是动态数据类型，值的数据类型和值本身，而不是和它的容器，关联在一起的。存储类&emsp;&emsp;每个存储在SQLite数据库中（或被数据库引擎操纵的）的值都有下列存储类的一个：1.NULL：空值。2.INTEGER：带符号的整型，具体取决于存入数字的范围大小。3.REAL：浮点数字，存储为8-byte IEEE浮点数。4.TEXT：字符串文本。5.BLOB：二进制对象。数据类型&emsp;&emsp;实际上，sqlite3也接受如下的数据类型：smallint 16 位元的整数。integer 32 位元的整数。decimal(p,s) p 精确值和 s 大小的十进位整数，精确值p是指全部有几个数(digits)大小值，s是指小数点後有几位数。如果没有特别指定，则系统会设为 p=5; s=0 。float 32位元的实数。double 64位元的实数。char(n) n 长度的字串，n不能超过 254。varchar(n) 长度不固定且其最大长度为 n 的字串，n不能超过 4000。graphic(n) 和 char(n) 一样，不过其单位是两个字元 double-bytes， n不能超过127。这个形态是为了支援两个字元长度的字体，例如中文字。vargraphic(n) 可变长度且其最大长度为 n 的双字元字串，n不能超过 2000date 包含了 年份、月份、日期。time 包含了 小时、分钟、秒。timestamp 包含了 年、月、日、时、分、秒、千分之一秒。datetime 包含日期时间格式，必须写成’2010-08-05’不能写为’2010-8-5’，否则在读取时会产生错误！&emsp;&emsp;注意存储类（storage class）比数据类型更一般。INTEGER存储类，例如，包含6种长度不同的整数数据类型。这在磁盘中是有区别的。不过一旦INTEGER值从磁盘读到内容中进行处理的时候，这些值会转化为更普通的数据类型（8位有符号整数）。因此在大部分情况下，存储类和数据类型是不易分辨的，这两个术语可以交换使用。&emsp;&emsp;当然，由于SQLite是无类型的. 所以可以保存任何类型的数据到任何表的任何列中, 无论这列声明的数据类型是什么(只有自动递增Integer Primary Key才有用). 对于SQLite来说对字段不指定类型是完全有效的. 如:1Create Table ex3(a, b, c); &emsp;&emsp;尽管SQLite允许忽略数据类型, 最好还是在创建表时指定数据类型. 因为指定数据类型便于理解交流, 也便于更换数据库引擎。常见的数据类型有：1234567891011121314CREATE TABLE IF NOT EXISTS ex2( a VARCHAR(10), b NVARCHAR(15), c TEXT, d INTEGER, e FLOAT, f BOOLEAN, g CLOB, h BLOB, i TIMESTAMP, j NUMERIC(10,5), k VARYING CHARACTER (24), l NATIONAL VARYING CHARACTER(16) ); char、varchar、text和nchar、nvarchar、ntext的区别1、CHAR。CHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。2、VARCHAR。存储变长数据，但存储效率没有CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么“+1”呢？这一个字节用于保存实际使用了多大的长度。从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。3、TEXT。text存储可变长度的非Unicode数据，最大长度为2^31-1(2,147,483,647)个字符。4、NCHAR、NVARCHAR、NTEXT。这三种从名字上看比前面三种多了个“N”。它表示存储的是Unicode数据类型的字符。我们知道字符中，英文字符只需要一个字节存储就足够了，但汉字众多，需要两个字节存储，英文与汉字同时存在时容易造成混乱，Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。nchar、nvarchar的长度是在1到4000之间。和char、varchar比较起来，nchar、nvarchar则最多存储4000个字符，不论是英文还是汉字；而char、varchar最多能存储8000个英文，4000个汉字。可以看出使用nchar、nvarchar数据类型时不用担心输入的字符是英文还是汉字，较为方便，但在存储英文时数量上有些损失。&emsp;&emsp;所以一般来说，如果含有中文字符，用nchar/nvarchar，如果纯英文和数字，用char/varchar。&emsp;&emsp;SQL语句中的所有值，不管是SQL语句中嵌入的字面值，还是预编译的SQL语句中的参数，都有一个隐式的存储类。在下面描述的条件下，在查询执行阶段，数据库引擎可能会在数字存储类（INTEGER和REAL）和TEXT存储类之间转换。Boolean数据类型SQLite没有单独的Boolean存储类，相反，Booean值以整数0（false）和1（true）存储。日期和时间数据类型SQLite没有为存储日期和/或时间设置专门的存储类，相反，内置的日期和时间函数能够把日期和时间作为TEXT，REAL或INTEGER值存储：TEXT：作为ISO8601字符串（”YYYY-MM-DD HH:MM:SS.SSS”）。REAL：作为Julian天数，……INTEGER：作为Unix Time，即自1970-01-01 00:00:00 UTC以下的秒数。类型相像（type affinity）&emsp;&emsp;为了最大化SQLite和其他数据库引擎之间的兼容性，SQLite支持列的”类型相像“的概念。这里重要的思想是，类型是推荐的，不是必需的。任何列仍然能够存储任何类型的数据。只是某些列，能够选择优先使用某种存储类。这个对列的优先存储类称作它的”相像“。&emsp;&emsp;SQLite 3 数据库中的每个列都赋予下面类型相像中的一个：TEXTNUMERICINTEGERREALNONE&emsp;&emsp;带有TEXT相像的列会使用存储类NULL、TEXT或BLOB来存储所有的数据。如果数据数据被插入到带有TEXT相像的列中，它会在插入前转换为文本格式。&emsp;&emsp;带有NUMERIC相像的列可以使用所有5个存储类来包含值。当文本数据被插入到一个NUMERIC列，文本的存储类会被转换成INTEGER或REAL（为了优先），如果这个转换是无损的和可逆的话。如果TEXT到INTEGER或REAL的转换是不可能的，那么值会使用TEXT存储类存储。不会试图转换NULL或BLOB值。列相像的确定&emsp;&emsp;列相像是由列声明的类型确定的，规则是按照下面的顺序：1. 如果声明的类型包含字符串”INT“那么它被赋予INTEGER相像。 2. 如果列声明的类型包含任何字符串”CHAR“，”CLOB“，或”TEXT“，那么此列拥有TEXT相像。注意类型VARCHAR包含”CHAR“，因此也会赋予TEXT相像。 3. 如果列声明的类型包含”BLOB“或没有指定类型，那么此列拥有NONE相像。 4. 如果列声明的类型包含任何”REAL“，”FLOA“，或”DOUB“，那么此列拥有REAL相像。 5. 其他情况，相像是NUMERIC。 注意规则的顺序是重要的。声明类型为“CHARINT”的列同时匹配规则1和规则2，但第一个规则会优先采用，因此此列的相像是INTEGER。比较表达式Sqlite v3有一系列有用的比较操作符，包括 &quot;=&quot;, &quot;==&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;!=&quot;, &quot;&lt;&gt;&quot;, &quot;IN&quot;, &quot;NOT IN&quot;, &quot;BETWEEN&quot;, &quot;IS&quot;, 和 &quot;IS NOT&quot; 排序&emsp;&emsp;比较操作的结果基于操作数的存储类型，根据下面的规则：存储类型为NULL的值被认为小于其他任何的值（包括另一个存储类型为NULL的值）; 一个INTEGER或REAL值小于任何TEXT或BLOB值。当一个INTEGER或REAL值与另外一个INTEGER或REAL值比较的话，就执行数值比较; TEXT值小于BLOB值。当两个TEXT值比较的时候，就根据序列的比较来决定结果; 当两个BLOB值比较的时候，使用memcmp来决定结果. 比较操作数的近似（Affinity）&emsp;&emsp;Sqlite可能在执行一个比较之前会在INTEGER，REAL或TEXT之间转换比较值。是否在比较操作之前发生转换基于操作数的近似（类型）。操作数近似（类型）由下面的规则决定： 对一个列的简单引用的表达式与这个列有相同的affinity，注意如果X和Y.Z是列名，那么+X和+Y.Z均被认为是用于决定affinity的表达式 一个”CAST(expr as type)”形式的表达式与用声明类型为”type”的列有相同的affinity 其他的情况，一个表达式为NONE affinity 在比较前的类型转换&emsp;&emsp;只有在转换是无损、可逆转的时候“应用近似”才意味着将操作数转换到一个特定的存储类。近似在比较之前被应用到比较的操作数，遵循下面的规则（根据先后顺序）:如果一个操作数有INTEGER，REAL或NUMERIC近似，另一个操作数有TEXT或NONE近似，那么NUMERIC近似被应用到另一个操作数; 如果一个操作数有TEXT近似，另一个有NONE近似，那么TEXT近似被应用到另一个操作数; 其他的情况，不应用近似，两个操作数按本来的样子比较; 表达式&quot;a BETWEEN b AND c&quot;表示两个单独的二值比较” a &gt;= b AND a &lt;= c”，即使在两个比较中不同的近似被应用到’a’。 操作符&emsp;&emsp;所有的数学操作符(+, -, *, /, %, &lt;&lt;, &gt;&gt;, &amp;, |)，在被执行前，都会将两个操作数都转换为数值存储类型（INTEGER和REAL）。即使这个转换是有损和不可逆的，转换仍然会执行。一个数学操作符上的NULL操作数将产生NULL结果。一个数学操作符上的操作数，如果以任何方式看都不像数字，并且又不为空的话，将被转换为0或0.0。&emsp;&emsp;有兴趣了解更多可以参考这里","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"sqlite","slug":"sqlite","permalink":"https://github.com/lsfst/lsfst.github.io/tags/sqlite/"}]},{"title":"java集成sqlite","slug":"java集成sqlite","date":"2018-12-22T16:00:00.000Z","updated":"2019-03-31T12:06:23.557Z","comments":true,"path":"2018/12/23/java集成sqlite/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/12/23/java集成sqlite/","excerpt":"","text":"sqlite是啥？&emsp;&emsp;sqlite，是一款轻型的、嵌入式的关系型数据库。它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。它能够支持Windows/Linux/Unix等等主流的操作系统，同时能够跟很多程序语言相结合。与Mysql、PostgreSQL相比，sqlite的处理速度更快。它的使用非常简单，无需安装和管理。一个完整的 sqlite 数据库是存储在一个单一的跨平台的磁盘文件，简单的说一个数据库就是一个单一文件。SQLite虽然很小巧，但是支持的SQL语句不会逊色于其他开源数据库，它支持的大多数的SQL语句。目前最新的版本是sqlite3。安装流程下载地址windows1.下载 sqlite-tools-win32-.zip 和 sqlite-dll-win32-.zip 压缩文件2.解压上面两个压缩文件，将得到 sqlite3.def、sqlite3.dll 和 sqlite3.exe 文件3添加 PATH 环境变量linux/MacOS&emsp;&emsp;目前linux 操作系统都附带 sqlite，可以使用命令：sqlite3 来检查机器上是否已经安装了 SQLite。&emsp;&emsp;万一没安装，可以下载sqlite-autoconf-*.tar.gz解压安装12345$tar xvfz sqlite-autoconf-3071502.tar.gz$cd sqlite-autoconf-3071502$./configure --prefix=/usr/local$make$make installJava集成sqlite&emsp;&emsp;相对于mysql来说，在项目中使用sqlite的好处在于可以省去外部mysql的配置安装，直接将sqlite数据库的单一文件放在项目里一起打包过去，或者直接指定机器磁盘上的某个位置生成数据库文件。在java项目中内嵌sqlite很简单，无需手动安装数据库。对于springboot项目，只需要引入sqlite-jdbc 和 spring-boot-starter-jdbc依赖即可。12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.xerial&lt;/groupId&gt; &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt; &lt;version&gt;3.21.0.1&lt;/version&gt;&lt;/dependency&gt;简单封装的数据库工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159public class SqliteUtils &#123; final static Logger logger = LoggerFactory.getLogger( SqliteUtils.class); private String dbFilePath; private Connection connection; private Statement statement; private ResultSet resultSet; /** * 构造函数 * @throws ClassNotFoundException * @throws SQLException */ public SqliteUtils(String dbFilePath) throws ClassNotFoundException, SQLException &#123; this.dbFilePath=dbFilePath; connection = getConnection(dbFilePath); logger.info( dbFilePath+\" connected successful\"); &#125; /** * 获取数据库连接 * @param dbFilePath db文件路径 * @return 数据库连接 * @throws ClassNotFoundException * @throws SQLException */ public Connection getConnection(String dbFilePath) throws ClassNotFoundException, SQLException &#123; //sqlite在进行连接时，若找不到数据库，会自动在对应目录创建一个db文件。 Connection conn = null; Class.forName(\"org.sqlite.JDBC\"); conn = DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath); return conn; &#125; /** * 执行sql查询 * @param sql sql select 语句 * @param rse 结果集处理类对象 * @return 查询结果 * @throws SQLException * @throws ClassNotFoundException */ public &lt;T&gt; T executeQuery(String sql, ResultSetExtractor&lt;T&gt; rse) throws SQLException, ClassNotFoundException &#123; try &#123; resultSet = getStatement().executeQuery(sql); T rs = rse.extractData(resultSet); return rs; &#125; finally &#123; destroyed(); &#125; &#125; /** * 执行select查询，返回结果列表 * * @param sql sql select 语句 * @param rm 结果集的行数据处理类对象 * @return * @throws SQLException * @throws ClassNotFoundException */ public &lt;T&gt; List&lt;T&gt; executeQuery( String sql, RowMapper&lt;T&gt; rm) throws SQLException, ClassNotFoundException &#123; List&lt;T&gt; rsList = new ArrayList&lt;T&gt;(); try &#123; resultSet = getStatement().executeQuery(sql); while (resultSet.next()) &#123; rsList.add(rm.mapRow(resultSet, resultSet.getRow())); &#125; &#125; finally &#123; destroyed(); &#125; return rsList; &#125; /** * 执行数据库更新sql语句 * @param sql * @return 更新行数 * @throws SQLException * @throws ClassNotFoundException */ public int executeUpdate(String sql) throws SQLException, ClassNotFoundException &#123; try &#123; int c = getStatement().executeUpdate(sql); return c; &#125; finally &#123; destroyed(); &#125; &#125; /** * 执行多个sql更新语句 * @param sqls * @throws SQLException * @throws ClassNotFoundException */ public void executeUpdate(String...sqls) throws SQLException, ClassNotFoundException &#123; try &#123; for (String sql : sqls) &#123; getStatement().executeUpdate(sql); &#125; &#125; finally &#123; destroyed(); &#125; &#125; /** * 执行数据库更新 sql List * @param sqls sql列表 * @throws SQLException * @throws ClassNotFoundException */ public void executeUpdate(List&lt;String&gt; sqls) throws SQLException, ClassNotFoundException &#123; try &#123; for (String sql : sqls) &#123; getStatement().executeUpdate(sql); &#125; &#125; finally &#123; destroyed(); &#125; &#125; private Connection getConnection() throws ClassNotFoundException, SQLException &#123; if (null == connection) connection = getConnection(dbFilePath); return connection; &#125; private Statement getStatement() throws SQLException, ClassNotFoundException &#123; if (null == statement) statement = getConnection().createStatement(); return statement; &#125; /** * 数据库资源关闭和释放：rs-&gt;st-&gt;conn 按照顺序关闭 */ public void destroyed() &#123; try &#123; if (null != resultSet) &#123; resultSet.close(); resultSet = null; &#125; if (null != statement) &#123; statement.close(); statement = null; &#125; if (null != connection) &#123; connection.close(); connection = null; &#125; &#125; catch (SQLException e) &#123; logger.error(\"Sqlite 数据库关闭时异常\", e); &#125; &#125;&#125;连接测试1234567891011121314151617181920212223242526@Testpublic void testHelper() &#123; try &#123; SqliteUtils h = new SqliteUtils(\"sqlite.db\"); h.executeUpdate(\"drop table if exists user;\"); h.executeUpdate(\"create table user(name varchar(20),desc TEXT);\"); h.executeUpdate(\"insert into user (name) values('zhangsan');\"); h.executeUpdate(\"insert into user (name) values('lisi');\"); h.executeUpdate(\"insert into user (name) values('wangwu');\"); List&lt;String&gt; sList = h.executeQuery(\"select name from user\", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow( ResultSet rs, int index) throws SQLException &#123; return rs.getString(\"name\"); &#125; &#125;); for(String s:sList)&#123; System.out.println(s); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;&emsp;&emsp;连接的时候首先会去检测是否存在数据库文件，不存在则自动创建sqlite.db文件，所以无需手动创建db文件。","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"},{"name":"sqlite","slug":"sqlite","permalink":"https://github.com/lsfst/lsfst.github.io/tags/sqlite/"}]},{"title":"windows下SkyWalking分布式链路跟踪系统踩坑记录","slug":"windowsSkyWalking","date":"2018-12-10T16:00:00.000Z","updated":"2019-03-12T15:53:27.257Z","comments":true,"path":"2018/12/11/windowsSkyWalking/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/12/11/windowsSkyWalking/","excerpt":"","text":"简介&emsp;&emsp;SkyWalking 是一个针对分布式系统的 APM 系统，也被称为分布式追踪系统。&emsp;&emsp;skywalaking总体架构分为三部分：&emsp;&emsp;skywalking-collector：链路数据收集器，数据可以落地ElasticSearch，单机也可以落地H2，但不推荐&emsp;&emsp;skywalking-web：web可视化平台，用来展示落地的数据&emsp;&emsp;skywalking-agent：探针，用来收集和发送数据到归集器&emsp;&emsp;当然，实际上部署起来其实很简单，不需要了解原理就可以正常使用。部署安装ElasticSearch&emsp;&emsp;必须选择5.X版本的ElasticSearch下载,最新的6.X以上的版本暂不兼容(文档没看仔细，在这浪费了不少时间)，同时要求JDK8+下载SkyWalking安装包&emsp;&emsp;获取Apache的最新发布的稳定版本或者下载github上面的源码在稳定版本的tag上进行编译，我选择的是5.0的版本下载，解压后目录结构如下：配置修改ElasticSearch:config/elasticsearch.yml123456# 修改 # 如果 cluster.name 不设置为 CollectorDBCluster ，则需要修改 SkyWalking 的配置文件 cluster.name: CollectorDBCluster network.host: 0.0.0.0 # 增加 thread_pool.bulk.queue_size: 1000skywalking:config/application.yml :运行&emsp;&emsp;运行bin 目录下的start.sh/start.bat脚本，会同时启动Collector和Web UI。访问localhost:8080，可以进入web页面，默认账号密码都是admin，具体可以在webapp.yml配置。遇到下面错误可参考解决方法：服务器500：多半是配置上的问题，可能是collector未正常连接，先去logs目录下查看对应日志；找不到Collector：检查下webapp/webapp.yml 中collector.ribbon.listOfServers 配置的地址是否正确;找不到9200端口：可能是config/application.yml中ElasticSearch节点配置不正确，Elastic启动时会启动两个端口，9300是tcp通讯端口，集群间和TCPClient都走的它，9200是http协议的RESTful接口，这里应该配置9300端口.Agent探针&emsp;&emsp;拷贝apache-skywalking-apm-incubating目录下的agent目录到应用程序位置，探针包含整个目录，不要改变目录结构；java程序启动时，增加JVM启动参数，-javaagent:/path/to/agent/skywalking-agent.jar。参数值为skywalking-agent.jar的绝对路径&emsp;&emsp;同时修改agent.config配置中的agent.application_code为要监控的应用的名字，其他默认即可。&emsp;&emsp;最后启动应用elasticsearch-head&emsp;&emsp;elasticsearch-head是一个ElasticSearch的可视化监控插件，可以用来监视ElasticSearch运行情况，安装起来很简单，但是需要安装Node环境。12345git clone git://github.com/mobz/elasticsearch-head.gitcd elasticsearch-headnpm installnpm run start &emsp;&emsp;然后打开 http://localhost:9100/ 就能看到ElasticSearch节点信息了","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"}]},{"title":"海量数据与BitSet","slug":"海量数据与BitSet","date":"2018-11-11T16:00:00.000Z","updated":"2019-03-12T17:10:45.354Z","comments":true,"path":"2018/11/12/海量数据与BitSet/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/11/12/海量数据与BitSet/","excerpt":"","text":"现在有五十亿个int类型的正整数，从中找出重复的数并返回。&emsp;&emsp;这种问题，首先想到的就是内存问题。50亿个int数，一共约占用4*50亿字节=20G内存，对于一般机器来说一次性加载进内存基本是不可能的。&emsp;&emsp;因为数据量较大，如果采取遍历，那时间复杂度也需要考虑。所有数都是int类型，可以考虑用一个int数组接收所有值，把int正整数n作为数组下标，如果n存在，则对应的值为1，如果不存在，对应的值为0。例如数组arr[n] = 1，表示n存在，arr[n] = 0表示n不存在。由于int非负整数一共有 2^31 个，所以数组的大小需要 2^32 （约21亿）这么大。这样的话，只需要一次遍历，就可以找出所有重复的数了。这样的话，2^32的int数组，其所需内存大约是8G。&emsp;&emsp;问题只需要找出重复值，不需要统计各重复值个数，所以这个int数组可以用boolean数组代替。&emsp;&emsp;《Java虚拟机规范》虽然定义了boolean这种类型，但只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。也就是说，一个boolean值占用内存4个字节的空间；但一个boolean数组中的每一个值占用内存1个字节的空间。这样子，将int数组转换成boolean数组，占用内存可以下降到原来四分之一，也就是2G内存。即使这样，内存要求还是太大了。&emsp;&emsp;虽然boolean是表示两种状态，但是boolean实际上占用了8bit，按道理8bit是可以表示128种状态的，但现在只能表示两种状态，还是太浪费了。既然这样，不如再大胆一点，直接用一个字节表示状态。BitMap算法&emsp;&emsp;用1位来表示一个数据是否出现过，0为没有出现过，1表示出现过。使用的时候可以根据某一个位是否为0表示此数是否出现过，这种算法称做bitmap算法。JDK中的BitSet集合对是就是对Bitmap的相对简单的实现Java中BitSet实现123456789101112131415161718192021222324252627282930313233343536373839public class BitSet implements Cloneable, java.io.Serializable &#123; private final static int ADDRESS_BITS_PER_WORD = 6; private final static int BITS_PER_WORD = 1 &lt;&lt; ADDRESS_BITS_PER_WORD; private final static int BIT_INDEX_MASK = BITS_PER_WORD - 1; private static final long WORD_MASK = 0xffffffffffffffffL;//bitset的内部实现是long数组private long[] words;//bitSet当前word数，也即words长度private transient int wordsInUse = 0;//BitSet默认的是一个long整形的大小public BitSet() &#123; initWords(BITS_PER_WORD); sizeIsSticky = false;&#125;public BitSet(int nbits) &#123; // nbits can't be negative; size 0 is OK if (nbits &lt; 0) throw new NegativeArraySizeException(\"nbits &lt; 0: \" + nbits); initWords(nbits); sizeIsSticky = true;&#125;//初始化wordsprivate void initWords(int nbits) &#123; words = new long[wordIndex(nbits-1) + 1];&#125;//根据bit数计算对应word数，右移6位private static int wordIndex(int bitIndex) &#123; return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;&#125;//私有构造private BitSet(long[] words) &#123; this.words = words; this.wordsInUse = words.length; checkInvariants();&#125;&#125;&emsp;&emsp;BitSet的底层实现是使用long数组作为内部存储结构的，这就决定了BitSet的大小为long类型大小(64位)的整数倍。long数组的每一个元素都可以当做是64位的二进制数，也是整个BitSet的子集。在BitSet中把这些子集叫做Word。&emsp;&emsp;BitSet对外提供了两个公有构造函数，一个无参，默认的初始大小为64bit，另一个构造函数带一个int型参数用于指定大小。默认情况下，每个位的默认值为false(0)。BitSet的基本操作&emsp;&emsp;BitSet对数据的基本操作都是通过位操作来实现的。set()方法是其中的核心。当要增加一个元素时，修改该元素在BitSet中的对应位值为1；当要删除一个元素时，修改该元素在BitSet中的对应位值为0。新增123456789101112131415161718public void set(int bitIndex, boolean value) &#123; if (value) set(bitIndex); else clear(bitIndex);&#125;public void set(int bitIndex) &#123; if (bitIndex &lt; 0) throw new IndexOutOfBoundsException(\"bitIndex &lt; 0: \" + bitIndex); //获取所在下标 int wordIndex = wordIndex(bitIndex); expandTo(wordIndex); //与 words[wordIndex] |= (1L &lt;&lt; bitIndex); // Restores invariants checkInvariants();&#125;&emsp;&emsp;举个栗子，我们要添加一个值n=84。&emsp;&emsp;先找到n在words数组中的下标index，index = 1。然后再找到n在words[index]中的位置position，这里position = 84%64=20。12index = n / 64 = n &gt;&gt; 6。position = n % 64 = n &amp; 0x40。&emsp;&emsp;接下来我们把1向←移动position个二进制位，然后把所得的结果和arr[index]做“或(or)”操作就可以了（位移超过64位溢出自动舍弃，1&lt;&lt;65=1&lt;&lt;1），所以对于long类型组成的words[]来说，position的位置可以不用计算：1words[wordIndex] |= (1L &lt;&lt; n)&emsp;&emsp;除此之外，添加元素时还要考虑数组扩容问题:基础扩容倍数是2，扩容后的数组大小取2*当前数组大小与所需大小的最大值。12345678910111213141516private void expandTo(int wordIndex) &#123; int wordsRequired = wordIndex+1; // if (wordsInUse &lt; wordsRequired) &#123; ensureCapacity(wordsRequired); wordsInUse = wordsRequired; &#125;&#125;private void ensureCapacity(int wordsRequired) &#123; if (words.length &lt; wordsRequired) &#123; // Allocate larger of doubled size or required size int request = Math.max(2 * words.length, wordsRequired); words = Arrays.copyOf(words, request); sizeIsSticky = false; &#125;&#125;删除123456789101112131415161718192021222324252627282930//删除某个数据public void clear(int bitIndex) &#123; if (bitIndex &lt; 0) throw new IndexOutOfBoundsException(\"bitIndex &lt; 0: \" + bitIndex); int wordIndex = wordIndex(bitIndex); if (wordIndex &gt;= wordsInUse) return; words[wordIndex] &amp;= ~(1L &lt;&lt; bitIndex); //重新计算数组大小 recalculateWordsInUse(); checkInvariants();&#125;private void recalculateWordsInUse() &#123; // Traverse the bitset until a used word is found int i; for (i = wordsInUse-1; i &gt;= 0; i--) if (words[i] != 0) break; wordsInUse = i+1; // The new logical size&#125;//清空所有数据 public void clear() &#123; while (wordsInUse &gt; 0) words[--wordsInUse] = 0;&#125;&emsp;&emsp;只需要把对应的二进制的1变成0即可，把1←移后的结果取反，然后与arr[index]做“与”操作，每次删除后会重新计算数组大小。查询12345678910public boolean get(int bitIndex) &#123; if (bitIndex &lt; 0) throw new IndexOutOfBoundsException(\"bitIndex &lt; 0: \" + bitIndex); checkInvariants(); int wordIndex = wordIndex(bitIndex); return (wordIndex &lt; wordsInUse) &amp;&amp; ((words[wordIndex] &amp; (1L &lt;&lt; bitIndex)) != 0);&#125;&emsp;&emsp;计算出要查询的数对应words数组中的index，把1←移后，将结果和words[index]做“与”操作，如果结果不为0，则证明存在，否则就不存在反转把某一位的1变成0，0变成1，是一个与1的异或(^)运算的操作12345678910111213public void flip(int bitIndex) &#123; if (bitIndex &lt; 0) throw new IndexOutOfBoundsException(\"bitIndex &lt; 0: \" + bitIndex); int wordIndex = wordIndex(bitIndex); expandTo(wordIndex); words[wordIndex] ^= (1L &lt;&lt; bitIndex); recalculateWordsInUse(); checkInvariants();&#125;除此之外名，BitSet的新增，清空，查询，反转都提供了批量操作指定范围数据的方法BitSet的优缺点优点1. 运算效率高，不进行比较和移位； 2. 占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。 缺点1. 所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。 2. 当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。 应用回到先前的问题，五十亿个int类型的正整数，从中找出重复的数，采用bitSet存储的话，所需内存可以降到int数组的1/32，也即250M左右的内存空间即可满足要求。1234567891011121314151617public static Set&lt;Integer&gt; getRepeats( int arr[])&#123; //将重复的值存进set，防止返回重复的数 Set&lt;Integer&gt; set=new HashSet&lt;&gt;( ); //BitSet 双倍扩容机制 BitSet bitSet=new BitSet( Integer.MAX_VALUE ); for (int i=0; i&lt;arr.length ;i++)&#123; int value=arr[i]; //判断该数是否存在bitSet里，这样一次遍历即可得出结果 if(bitSet.get( value ))&#123; set.add( value ); &#125;else &#123; bitSet.set(value, true); &#125; &#125; return set;&#125;相关问题：&emsp;&emsp;给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？&emsp;&emsp;usinged int只有接近43亿数，用BitSet存储的话只需要0.5G内存，一个bit位代表一个unsigned int值，读入40亿个数，设置相应的bit位；读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。&emsp;&emsp;当然，其实这里还有优化空间，可以考虑去存储那不存在的接近3亿数。一般来说，存储3亿数所需空间是小于存储40亿数据所需空间的，不过这需要先遍历找出这3亿数中的最大值与最小值，所以会增加时间复杂度。&emsp;&emsp;已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。&emsp;&emsp;8位最多99 999 999，大概需要99m个bit，大概10几M字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个bit位，所以只需要99M个bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）&emsp;&emsp;大数据量无重复数排序：位图法&emsp;&emsp;大数据量有重复数排序：如果只有少量重复次数，可以将BitSet进行扩展，比如用两个bit位表示一个数，一位表示存在与否，一位表示重复次数（但仅限2次以内）","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lsfst/lsfst.github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://github.com/lsfst/lsfst.github.io/tags/算法/"}]},{"title":"ElementUI + vue 定制一个表格插件","slug":"element-vue-table","date":"2018-11-11T02:01:22.000Z","updated":"2019-03-31T12:25:13.570Z","comments":true,"path":"2018/11/11/element-vue-table/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/11/11/element-vue-table/","excerpt":"","text":"&emsp;&emsp;公司后台管理系统有很多表格页面，分别对应数据库不同的表。整个后台UI使用的是Element UI，Element UI的表格功能很强大，但是如果拿来直接用，会产生大量的模板代码，再加上各种个性化功能和自定义配置，一个一个写起来既麻烦又难看。&emsp;&emsp;正是基于此才需要对表格进行封装，希望达到的效果如下:12345678tableList: [ &#123;name: &apos;keyID&apos;, width: &#123;length: 100&#125;,sort:true,show: true&#125;, &#123;name: &apos;Type&apos;,show:true,width:&#123;length:150&#125;,format:&#123;comData:cdrTypeKeyValue&#125;&#125;, &#123;name: &apos;dataTraffic&apos;,format:&#123;trafficFM:true&#125;, sort:true,type:&quot;tag&quot;,tagData:function(value)&#123; return value&gt; 0 ? (value&lt;1000000?&quot;info&quot;:&quot;warning&quot;) : &quot;danger&quot;; &#125;,width: &#123;length: 160&#125;,show: true&#125;, &#123;name: &apos;crtTm&apos;, show: true,type:&apos;date&apos;,width: &#123;length: 200&#125;&#125;,]在创建一个新的表格页面时，只需要利用如上的表格字段配置就可以完成渲染，增删查改，排序，自定义样式等大部分工作。当然，这种模板是比较特性化的，主要根据具体业务而定。表格组件simpleTableTemplate.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;template xmlns:v-bind=\"http://www.w3.org/1999/xhtml\"&gt; &lt;div&gt; &lt;el-table v-loading=\"listLoading\" element-loading-text=\"拼命加载中\" element-loading-background=\"rgba(0, 0, 0, 0.8)\" ref=\"elTable\" :data=\"computedLists\" @select=\"selectionChange\" @select-all=\"selectionAll\" @row-click=\"clickRow\" max-height=\"700\" highlight-current-row style=\"width: 100%;\" :row-class-name=\"tableRowClassName\" &gt; &lt;el-table-column v-if=\"check\" fixed=\"left\" :prop=\"tableKey\" type=\"selection\" width=\"35\"&gt; &lt;/el-table-column&gt; &lt;template v-for=\"item in columnList\"&gt; &lt;el-table-column v-if=\"item.sort\" :width=\"item.width.length\" align=\"center\" :label=\"$t(prefix+item.name)\" :render-header=\"(h,obj,index) =&gt; renderSort(h,obj,index,item.name)\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;i v-if=\"item.type=='date'\" class=\"el-icon-time\"&gt;&lt;/i&gt; &lt;span v-if=\"item.type=='html'\" v-html=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;el-tooltip v-else-if=\"item.type=='tip'\" placement=\"top\"&gt; &lt;div slot=\"content\" v-html=\"scope.row.showData.tips[item.name]\"&gt;&lt;/div&gt; &lt;span v-html=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;/el-tooltip&gt; &lt;span v-else-if=\"item.type=='date'\" v-text=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;el-tag v-else-if=\"item.type=='tag'\" :type=\"scope.row.showData.tags[item.name]\" :style=\"item.style\"&gt;&lt;/el-tag&gt; &lt;span v-else v-text=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column v-else :width=\"item.width.length\" align=\"center\" :label=\"$t(prefix+item.name)\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;i v-if=\"item.type=='date'\" class=\"el-icon-time\"&gt;&lt;/i&gt; &lt;span v-if=\"item.type=='html'\" v-html=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;el-tooltip v-else-if=\"item.type=='tip'\" placement=\"top\"&gt; &lt;div slot=\"content\" v-html=\"scope.row.showData.tips[item.name]\"&gt;&lt;/div&gt; &lt;span v-html=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;/el-tooltip&gt; &lt;span v-else-if=\"item.type=='date'\" v-text=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;el-tag v-else-if=\"item.type=='tag'\" :type=\"scope.row.showData.tags[item.name]\" :style=\"item.style\"&gt;&lt;/el-tag&gt; &lt;span v-else v-text=\"scope.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/template&gt; &lt;el-table-column type=\"expand\" fixed=\"right\" v-if=\"expand\"&gt; &lt;template slot-scope=\"props\"&gt; &lt;el-form label-position=\"left\" inline class=\"demo-table-expand\"&gt; &lt;el-form-item v-for=\"item in expandList\" :key=\"item.name\" :label=\"$t(prefix+item.name)\" :style=\"item.style\"&gt; &lt;span v-html=\"props.row.showData[item.name]\"&gt;&lt;/span&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!--expand扩展框支持--&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; /** * @author lsf * @Date 2018/10/8 18:13 * @Description * expand 在点击展开的时候才会触发，之后值会缓存起来 * * 一个完整的table的参数列表： * param required desc * :list-loading=\"listLoading\" * :table-key=\"tableKey\" Y 主键 * :expand=\"expand\" N 扩展框 * :check=\"check\" N checkbox * :prefix=\"prefix\" Y * :table-list=\"tableList\" Y 表格配置列表 * :computed-lists=\"computedLists\" Y 处理后的查询数据 * @tableRowClassName=\"tableRowClassName\" Y row样式 * @renderSort=\"renderSort\" Y 搜索表头 * @selectionAll=\"selectionAll\" N 全选事件 * @selectionChange=\"selectionChange\" N 选择事件 * */ export default &#123; name:\"simpleTableTemplate\", props:['tableKey','listLoading','expand','prefix','check','tableList','computedLists'], computed: &#123; //从tableList提取出expandList（expand列表），columnList(表格主体) columnList: function () &#123; let columnList=[]; let tableList = this.tableList; for (let i = 0; i &lt; tableList.length; i++) &#123; if(!tableList[i].expand &amp;&amp; !tableList[i].hide)&#123; columnList.push(tableList[i]) &#125; &#125; return columnList &#125;, expandList: function () &#123; let expandList=[]; let tableList = this.tableList; for (let i = 0; i &lt; tableList.length; i++) &#123; if(tableList[i].expand)&#123; expandList.push(tableList[i]) &#125; &#125; return expandList &#125;, &#125;, methods:&#123; renderSort(h,obj,index,name)&#123; //排序 return this.$parent.renderSort(h,obj,index,name) &#125;, tableRowClassName(&#123;row, rowIndex&#125;)&#123; //row样式 return this.$parent.tableRowClassName(&#123;row, rowIndex&#125;) &#125;, selectionAll(val,row)&#123; //checkbox全选 this.$emit('selectionAll',val, row) &#125;, selectionChange(val,row)&#123; this.$emit('selectionChange',val, row) &#125;, clickRow(row,event,column)&#123; //点击行事件 this.$refs.elTable.toggleRowSelection(row,true; if(this.expand)&#123; this.$refs.elTable.toggleRowExpansion(row) &#125; this.$emit('clickRow',row) &#125; &#125;, &#125;;&lt;/script&gt; 操作栏组件&emsp;&emsp;除了表格主体外，还需要操作栏，比如增删查改下载等，所以还需要用按钮写一个简单的操作栏组件operationsTemplate.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;template&gt; &lt;div&gt; &lt;el-button class=\"filter-item\" style=\"margin-left: 10px;\" type=\"primary\" icon=\"el-icon-refresh\" @click=\"handleRefresh\"&gt;refresh &lt;/el-button&gt; &lt;template v-for=\"item in operations\"&gt; &lt;el-button v-if=\"item=='add'\" class=\"filter-item\" style=\"margin-left: 10px;\" type=\"primary\" icon=\"el-icon-plus\" @click=\"handleCreate\"&gt;add &lt;/el-button&gt; &lt;el-button v-if=\"item=='edit'\" class=\"filter-item\" style=\"margin-left: 10px;\" type=\"primary\" icon=\"el-icon-edit\" :disabled=\"editDisable\" @click=\"handleUpdate\"&gt;edit &lt;/el-button&gt; &lt;el-button v-if=\"item=='remove'\" class=\"filter-item\" style=\"margin-left: 10px;\" type=\"danger\" icon=\"el-icon-delete\" :disabled=\"deleteDisable\" @click=\"handleDelete\"&gt;delete &lt;/el-button&gt; &lt;el-button v-if=\"item=='download'\" v-waves :loading=\"downloadLoading\" class=\"filter-item\" type=\"primary\" icon=\"el-icon-download\" @click=\"handleDownload\"&gt;export &lt;/el-button&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //操作栏：刷新查询（所有的表格都有），新增，编辑，修改，删除，导出 export default &#123; name:\"operationsTemplate\", props:['operations','downloadLoading','deleteDisable','editDisable'], methods:&#123; handleRefresh()&#123; this.$emit('handleRefresh') &#125;, handleCreate()&#123; this.$emit('handleCreate') &#125;, handleUpdate()&#123; this.$emit('handleUpdate') &#125;, handleDelete()&#123; this.$emit('handleDelete') &#125;, handleDownload()&#123; this.$emit('handleDownload') &#125; &#125; &#125;&lt;/script&gt;组成实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;template&gt; &lt;div class=\"app-container\"&gt; &lt;div class=\"filter-container\"&gt; &lt;el-col :span=\"6\"&gt; &lt;el-input :placeholder=\"$t('table.vid')\" v-model=\"listQuery.vid\" clearable prefix-icon=\"el-icon-search\" style=\"width: 90%;\" class=\"filter-item\"/&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;el-select v-model=\"listQuery.area\" class=\"filter-item\" :placeholder=\"$t('table.area')\" filterable remote style=\"width:90%\" clearable @focus=\"switchArea\" :remote-method=\"remoteAreaMethod\" :loading=\"selectLoading\" clearable&gt; &lt;el-option v-for=\"item in areaOptions\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\"/&gt; &lt;/el-select&gt; &lt;/el-col&gt; &lt;operationsTemplate :operations=\"operations\" :download-loading=\"downloadLoading\" @handleDownload=\"handleDownload\" @handleRefresh=\"handleRefresh\" &gt;&lt;/operationsTemplate&gt; &lt;/div&gt; &lt;div&gt; &lt;simpleTableTemplate :list-loading=\"listLoading\" :table-key=\"tableKey\" :expand=\"expand\" :check=\"check\" :prefix=\"prefix\" :table-list=\"tableList\" :computed-lists=\"computedLists\" @tableRowClassName=\"tableRowClassName\" @renderSort=\"renderSort\" @selectionAll=\"selectionAll\" @selectionChange=\"selectionChange\" &gt;&lt;/simpleTableTemplate&gt; &lt;div class=\"pagination-container\"&gt; &lt;el-pagination :current-page=\"listQuery.page\" :page-sizes=\"[10,20,30, 50]\" :page-size=\"listQuery.limit\" :total=\"total\" background layout=\"total, sizes, prev, pager, next, jumper\" @size-change=\"handleSizeChange\" @current-change=\"handleCurrentChange\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import simpleTableTemplate from '@/views/table/simpleTableTemplate' import operationsTemplate from '@/views/table/operationsTemplate' //import具体方法时，必须&#123;&#125;包裹 import &#123;fetch&#125; from '@/api/cdr' import &#123;areaS2&#125; from '@/api/select' import &#123;renderHeadSort, getList, selectionChange, selectionAll, debounce,computedFmt,remoteQuery,remoteInitQuery,handleDownload &#125; from '@/utils/tableCustom' const cdrTypeOptions = [ &#123;key: 'N', name: '在线呼叫'&#125;, &#123;key: 'C', name: '落地呼叫'&#125;, &#123;key: 'B', name: '落地回拨'&#125; ] const cdrTypeKeyValue = cdrTypeOptions.reduce((acc, cur) =&gt; &#123; acc[cur.key] = cur.name return acc &#125;, &#123;&#125;) export default &#123; name: 'cdrTable', components: &#123;simpleTableTemplate,operationsTemplate&#125;, data() &#123; return &#123; prefix:'table.tbCDR.', tableKey: 'keyCDRID', tableList: [ &#123;name: 'keyCDRID', width: &#123;length: 100&#125;,sort:true,show: true&#125;, &#123;name: 'cdrType',show:true,width:&#123;length:150&#125;,format:&#123;comData:cdrTypeKeyValue&#125;&#125;, &#123;name: 'dataTraffic',format:&#123;trafficFM:true&#125;, sort:true,type:\"tag\", tagData:function(value)&#123; return value&gt; 0 ? (value&lt;1000000?\"info\":\"warning\") : \"danger\"; &#125;,width: &#123;length: 160&#125;,show: true&#125;, &#123;name: 'area', show: true,width: &#123;length: 200&#125;,type:'html',format:&#123;areaFM:true&#125;&#125;, &#123;name: 'crtTm', show: true,type:'date',width: &#123;length: 200&#125;&#125;, &#123;name: 'crtBy', expand: true&#125;, ], check: false, expand: true, operations: ['download'], //操作栏操作配置 list: [], //API接口获取的原始数据 total: null, listLoading: true, listQuery: &#123; //查询参数：分页，范围，排序以及其他参数 page: 1, offset: 0, limit: 20, orderList: [] &#125;, areaOptions:[], //用户输入条件实时查询的结果存进areaOptions（默认20条） areaInitOptions:[], //为了减少element remote select的查询次数，选择将remote select初始（无条件）查询结果存进areaInitOptions downloadLoading: false, selectLoading: false, lastDebounce: undefined, //节流函数：对查询频率进行限制 lastModifyTm: undefined, &#125; &#125;, created() &#123; //查询并更新查询时间 this.getList() this.lastModifyTm = (new Date()).getTime() &#125;, computed: &#123; //对查询的原始数据进行处理成实际展示的文本 computedLists: function () &#123; return computedFmt.call(this,this.list,this.tableList) &#125; &#125;, mounted()&#123; //remote select初次查询 remoteInitQuery.call(this, areaS2,\"area\",\"area\") &#125;, watch: &#123; //watch监听搜索区用户输入，只要有变化则自动触发查询，这样子比较简单，但是这样有个小问题：搜索区有input框，select，remote select以及时间栏， //对于input框，用户每输入一个字符就会触发一次查询，这样子会导致访问次数太高，浪费网络资源。所以需要使用节流函数限制访问频率：具体设置是两秒触发一次查询 listQuery: &#123; handler(curVal, oldVal)&#123; debounce.call(this, 2000, function () &#123; this.getList() &#125;) &#125;, deep: true &#125;, &#125;, methods: &#123; getList() &#123; getList.call(this, fetch) &#125;, handleSizeChange(val) &#123; this.listQuery.limit = val this.listQuery.offset = (this.listQuery.page - 1) * this.listQuery.limit this.getList() &#125;, handleCurrentChange(val) &#123; this.listQuery.page = val this.listQuery.offset = (this.listQuery.page - 1) * this.listQuery.limit this.getList() &#125;, //重置搜索条件 handleRefresh() &#123; this.listQuery = &#123; page: 1, offset: 0, limit: 20, orderList: [] &#125; &#125;, //数据导出 handleDownload() &#123; const tHeader = this.tableList.map(function (value) &#123; return value.name; &#125;) handleDownload.call(this, tHeader, fetch) &#125;, renderSort(h, &#123;column, $index&#125;, index, name) &#123; return renderHeadSort.call(this, h, &#123;column, $index&#125;, index, name) &#125;, //地区select框的remote查询 remoteAreaMethod(query)&#123; remoteQuery.call(this, areaS2,query, \"area\",\"area\") &#125;, //select原始查询结果切换 switchArea()&#123; this.areaOptions = this.areaInitOptions &#125;, selectionChange(val, row)&#123; this.checkedRows = val; &#125;, selectionAll(val, row)&#123; this.checkedRows = val; &#125;, tableRowClassName(&#123;row, rowIndex&#125;) &#123; return ''; &#125;, &#125; &#125;&lt;/script&gt;说明1.API&emsp;&emsp;表格操作和select remote查询的api我习惯分别写在不同的的js文件中，这样方便管理，在具体需要使用时单独引用。&emsp;&emsp;查询的request使用的是axios，进行了单独封装，这里就不贴代码了。cdr.js1234567891011121314import request from '@/utils/request'import qs from 'qs'export function fetch(query) &#123; //直接对query操作会影响全局query let _query=JSON.parse(JSON.stringify(query)); _query.orderList = JSON.stringify(_query.orderList) return request(&#123; url: '/api/cdr', method: 'get', headers: &#123;'Authorization': \"Basic YWRtaW46MTIzNDU2\"&#125;, params: _query &#125;)select.js1234567891011import request from '@/utils/request'export function areaS2(query) &#123; query.pageSize=50 return request(&#123; url: '/api/select2/areaS2', method: 'get', headers: &#123;'Authorization': \"Basic YWRtaW46MTIzNDU2\"&#125;, params: query &#125;)&#125;tableCustom.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304/** * Created on 2018/9/18. * 表格相关的通用方法封装 * 需要引用vue对象，call/apply 更改上下文 * 总结通用属性: * tableKey-主键 * list-数据列表 * total-总数 * listLoading-loading标识 * listQuery-参数列表：通用参数&#123;page: 1,offset: 0,limit: 20,orderList: []&#125; * editDisable-编辑model显示标识 * deleteDisable-删除model显示标识 * checkedRows-checkbox选中列表 * downloadLoading -下载loading * selectLoading -select loading * lastDebounce -页面查询控制：作为定时任务标识作为节流控制 * lastModifyTm -页面查询控制：记录上次查询时间作为节流控制** / /** * @Date 2018/9/18 17:40 * @Description 查询：清空chckedRows * @param func :传入的是查询func * @return */export function getList(func) &#123; this.listLoading = true func(this.listQuery).then(response =&gt; &#123; var data = response.data.data; this.list = data.contentList this.total = data.totalElements this.checkedRows=[] this.listLoading = false &#125;).catch(() =&gt; &#123; this.listLoading = false this.$notify(&#123; title: this.$t('table.selectError'), message: this.$t('table.selectError'), type: 'warning', duration: 2000 &#125;) &#125;);&#125;export function handleDelete(func) &#123; let idList = this.checkedRows.map(item =&gt; &#123; return item.keyID || item[this.tableKey] ; &#125;) this.$confirm(this.$t('table.deleteTips').replace('&#123;&#125;',idList.length ), this.$t('table.tips'), &#123; confirmButtonText: this.$t('table.confirm'), cancelButtonText: this.$t('table.cancel'), type: 'warning' &#125;).then(() =&gt; &#123; func(idList).then(response =&gt; &#123; if (response.data.code == 0) &#123; this.$message(&#123; type: 'success', message: this.$t('table.deleteSuccess') &#125;); this.getList() &#125; else &#123; this.$message(&#123; type: 'error', message: this.$t('table.deleteFailure')+':'+response.data.reason &#125;); &#125; &#125;) &#125;).catch(() =&gt; &#123; this.$message(&#123; type: 'info', message: this.$t('table.deleteCancel') &#125;); &#125;);&#125;function formatJson(filterVal, jsonData) &#123; return jsonData.map(v =&gt; filterVal.map(j =&gt; &#123; return v[j] &#125;))&#125;export function handleDownload(tHeader,func) &#123; this.downloadLoading = true var exportListQuery = JSON.parse(JSON.stringify(this.listQuery)); exportListQuery.table_columns = tHeader.join(\",\") exportListQuery.offset = 0 //暂时限制1000条，可自由配置 exportListQuery.limit = 1000 func(exportListQuery).then(response =&gt; &#123; const exportData = formatJson(tHeader, response.data.data.contentList); import ('@/vendor/Export2Excel').then(excel =&gt; &#123; excel.export_json_to_excel(&#123; header: tHeader, data: exportData, filename: 'table-list' &#125;) this.$notify(&#123; title: this.$t('table.success'), message: this.$t('table.downLoadSuccess'), type: 'success', duration: 2000 &#125;) this.downloadLoading = false &#125;) &#125;)&#125;/** * @Date 2018/9/29 14:35 * @Param idle-间隔时间,action-方法 * @Description 针对页面查询的节流函数，控制页面请求频率 * queryList停止变化一段时间后才会开始更新 * 改进：这个延迟时间应该仅限制连续事件的触发即可，如果距离上一次更新时间超过两秒，应该直接执行 * @return */export function debounce (idle, action) &#123; let now=(new Date()).getTime() let ctx = this, args = arguments if(!this.lastModifyTm || now-this.lastModifyTm&gt;2000)&#123; this.lastModifyTm=now action.apply(ctx, args) &#125;else &#123; this.lastModifyTm=now return function()&#123; clearTimeout(this.lastDebounce) this.lastDebounce = setTimeout(function()&#123; action.apply(ctx, args) &#125;, idle) &#125;.apply(this) &#125;&#125;/** * @Date 2018/9/18 16:53 * @Description 自定义表头排序：render方法，给排序按钮绑定点击查询事件 * @return */export function renderHeadSort(h, &#123;column, $index&#125;, index, name) &#123; return h('span', [ h('span', column.label), h('span', [ h('i', &#123; attrs: &#123; id: name + '_up' &#125;, class: 'up',// style: 'margin-left: 5px;', on: &#123; click: () =&gt; &#123; let input = document.getElementById(name + '_up') let itemClass = input.className if (itemClass.indexOf(\"onU\") == -1) &#123; input.classList.add(\"onU\") document.getElementById(name + '_down').classList.remove(\"onU\") this.listQuery.orderList = this.listQuery.orderList.filter(function (item) &#123; return item[0] != name; &#125;); this.listQuery.orderList.push([name, 1]) &#125; else &#123; input.classList.remove(\"onU\") this.listQuery.orderList = this.listQuery.orderList.filter(function (item) &#123; return item[0] != name; &#125;); &#125; &#125; &#125;, &#125;), h('i', &#123; class: 'down', attrs: &#123; id: name + '_down' &#125;, on: &#123; click: () =&gt; &#123; let input = document.getElementById(name + '_down') let itemClass = input.className if (itemClass.indexOf(\"onU\") == -1) &#123; input.classList.add(\"onU\") document.getElementById(name + '_up').classList.remove(\"onU\") this.listQuery.orderList = this.listQuery.orderList.filter(function (item) &#123; return item[0] != name; &#125;); this.listQuery.orderList.push([name, 0]) &#125; else &#123; input.classList.remove(\"onU\") this.listQuery.orderList = this.listQuery.orderList.filter(function (item) &#123; return item[0] != name; &#125;); &#125; &#125; &#125;, &#125;), ] ), ]);&#125;/** * @Date 2018/10/18 10:14 * @Description compute方法，对查询道德数据进行处理转化成可以显示的文本 * 对于比较特殊和复杂的条件，允许直接在表格参数中定义成func传入，在这里调用 * 同时，由于进行更新删除操作时需要的是原始数据，故不可将原始数据与处理过的数据混淆 * @return */export function computedFmt(computedList,tableList) &#123; let format,name,obj; for(let i=computedList.length-1;i&gt;=0;i--)&#123; let tags = &#123;&#125;; let tips=&#123;&#125;; obj = JSON.parse(JSON.stringify(computedList[i])) for(let j=tableList.length-1;j&gt;=0;j--)&#123; name=tableList[j].name if(tableList[j].type==\"tag\")&#123; if(obj[name] || obj[name] ==0)&#123; //方法或对象 if(typeof tableList[j].tagData===\"function\")&#123; tags[name]=tableList[j].tagData(obj[name],obj) &#125;else&#123; tags[name]=tableList[j].tagData[obj[name]] &#125; &#125; &#125; if(tableList[j].type==\"tip\")&#123; try &#123; if(tableList[j].tips &amp;&amp; typeof tableList[j].tips === \"function\") &#123; //tips是函数 tips[name]=tableList[j].tips(obj[name],obj) //value,rowData参数 &#125; else &#123; //不是函数 tips[name]=tableList[j][name] &#125; &#125; catch(e) &#123; tips[name]=\"-\" &#125; &#125; if(tableList[j].format)&#123; format=tableList[j].format //优先执行自定义function，注意空值判断 if(format.fmt)&#123; if(typeof format.fmt === \"function\") &#123; //fmt是函数 let fmt=format.fmt.call(this,obj[name],obj) if(fmt.fmt)&#123; obj[name]=fmt.fmt &#125;else &#123; obj[name]=fmt &#125; &#125; &#125; if(!obj[name] &amp;&amp; obj[name]!=0)&#123; continue &#125; if(format.ratio)&#123; obj[name]=obj[name]/format.ratio &#125; if(format.decimals)&#123; obj[name]=toDecimals(obj[name],format.decimals) &#125; if(format.comData)&#123; obj[name]=format.comData[obj[name]] || obj[name] &#125; &#125; &#125; obj.tags=tags obj.tips=tips computedList[i].showData=obj &#125; return computedList;&#125;/** * * @param func remote select方法 * @param query 用户输入val * @param name 查询的column */export function remoteQuery(func,query,name) &#123; format=format || \"\" if (query !== '') &#123; this.selectLoading = true; func(&#123;query:query,idxOwnerId:'eu.'&#125;).then(response =&gt; &#123; this.selectLoading = false; const S2Data = response.data.data.items; this[name+'Options'] = S2Data.map(item =&gt; &#123; return &#123;value: item.id, label: item.text&#125;; &#125;); &#125;).catch(r =&gt; &#123; this.selectLoading = false &#125;) &#125;&#125;export function remoteInitQuery(func,name) &#123; format=format || \"\" func(&#123;query:'',idxOwnerId:'eu.'&#125;).then(response =&gt; &#123; const S2Data = response.data.data.items; this[name+'InitOptions'] = S2Data.map(item =&gt; &#123; return &#123;value: item.id, label: item.text&#125;; &#125;); this[name+'Options'] = this[name+'InitOptions']; &#125;)&#125;遇到的问题1.表格组件化的目的&emsp;&emsp;一为减少模板代码量，二为方便对代码进行管理，同时保持可扩展性。就本人使用了一段时间vue的体验来讲，使用组件写业务代码并不会使代码简洁，甚至显得更啰嗦，但是代码层次清晰明了，便于理解，而且vue的组件的生命周期能提供粒度更细的控制。2.原始数据与展示数据的单独保存&emsp;&emsp;大致上将业务上使用的表格分成了只提供查询功能的简单表格和提供了增删查改等的复杂表格。对于简单表格来讲，只需要进行查询和数据的展示，但对复杂表格来说，进行修改删除操作时，只有原始数据才是有意义的，所以将原始数据存进data的list中，方便进行其他操作时直接引用，而展示数据则在computed中处理后存进computedLists，computedLists直接与表格绑定3.在computed中转化数据&emsp;&emsp;这里可以使用Element UI自带的expressions和vue的filters模块，不得不说Element UI的功能很强大，一个简单的input组件都能封装上百行代码。。。&emsp;&emsp;expressions也可用作文本转换，但一来它不支持复杂的逻辑，二来expressions是直接混在组件template中的，大量使用会让代码结构显得混乱。filters相对expressions来说就规范点，但仍是嵌在template中，而且给每个vue实例写重复的filters也很烦。既然这样，不如直接在computed中一次性完成所有文本转换，这样代码量也少了很多。&emsp;&emsp;computed的第二个好处是性能好。就使用效果来看，computed与method没有区别，但性能上差距很大。method中，每次页面渲染时都会重新执行一次。而computed的特点是依赖收集、动态计算，依赖的值发生变化才会修改，否则取缓存值，因此对于非响应式依赖（如Date.now()），计算一次后将不会发生改变。多数情况下computed够用，但如果要在数据变化响应时，执行异步操作或开销较大的操作，可以使用watct。4.watch监听搜索并使用节流函数&emsp;&emsp;一开始我还傻乎乎的给每个输入框绑定事件，后来发现完全没必要弄得这么麻烦。直接将所有相关参数绑定到listQuery中，监听listQuery的变化即可。同时，为了防止文本输入框查询频率过高，加入了节流函数进行限制。5.renderHeadSort&emsp;&emsp;Element Table其实有提供现成的排序功能，无论是前端排序还是访问后端查询接口，但我不喜欢它的样式，所以自己写了一个(任性6.call/apply的使用&emsp;&emsp;tableCustom.js和table.vue实例中存在大量的call/apply方法，因为表格封装后只剩下少部分参数和方法在实例中，使用call/apply可以在外部代码中引用到这些方法，方便将这部分代码与通用的部分分离开来。而且由于项目中引入了vue-i18n国际化插件，而i18n又跟vue实例绑定，所以需要用到i18n做文本转换的部分不得不使用call/apply来获取vue实例。7.父子组件的两种通信方式12this.$emit(&apos;func&apos;,params) 子组件触发func事件，父组件监听，这种模式无法获取返回值；this.parent.func(params) 子组件直接调用父组件方法，可直接获取返回值，不过父组件中必须注册对应方法，否则报错。8.table参数中的format&emsp;&emsp;format即文本转换规则，是一个Object，里面可以存储多个规则，如:123decimals 小数点设置areaFM 地区样式comData 语义化，比如val=-1在页面显示失败，value=1显示成功,value=0显示进行中&emsp;&emsp;对于用的比较少的特殊规则，则可以直接传递对应function：12345678910if(format.fmt)&#123; if(typeof format.fmt === \"function\") &#123; //fmt是函数 let fmt=format.fmt.call(this,obj[name],obj) if(fmt.fmt)&#123; obj[name]=fmt.fmt &#125;else &#123; obj[name]=fmt &#125; &#125;&#125;9.mixin整合重复代码&emsp;&emsp;实际上这个表格仍有一部分(大概一百来行)可以压缩到mixin里面，这样子实际调用起来会显得更简洁，有时间再整理出来吧。效果&emsp;&emsp;这样子一个简单的表格组件就差不多完成了，个人感觉写的并不够好，不过既然能满足日常业务需求，也就不吹毛求疵了。另外这篇博客字有点多，可以拆开来的，不过本人懒癌发作，就不整理了（逃","categories":[{"name":"vue","slug":"vue","permalink":"https://github.com/lsfst/lsfst.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/lsfst/lsfst.github.io/tags/vue/"}]},{"title":"windows idea 搭建Node开发环境","slug":"Node环境","date":"2018-11-09T03:35:58.000Z","updated":"2018-12-01T13:35:14.302Z","comments":true,"path":"2018/11/09/Node环境/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/11/09/Node环境/","excerpt":"","text":"最近有点小闲，开始学习NodeJS相关的东西。之前Node与NPM已经安装好了，环境变量也设置ok：话不多说，npm install 四连走起（这里可以按照需要安装想要的包）：1234npm install express -g npm install jade -gnpm install mysql -gnpm install -g express-generator在安装jade时直接报警告了:原来是改名成pug了，问题不大，继续下一步！在控制台运行：由于平时干后端习惯了使用idea，而且idea也提供了NodeJS插件，所以接下来直接在idea中安装NodeJS插件。打开idea，File -&gt; setting -&gt;Plugins,右边默认没有这个组件，需要手动点击Browe repositories..，在插件列表中搜索nodejs,将看到NodeJS插件，点击下载：然后：遇到这种情况可以直接去 idea plugin 官网下载插件直接输入NodeJS，回车，插件版本有很多，选了一个最新的版本下载，解压，将解压文件夹里面的NodeJS子文件夹复制到idea所在安装目录的plugins子文件夹中之后重启idea，安装按钮消失，看起来是ok了File -&gt; new -&gt;Project创建应用：没事，还有一个方法，将之前放在plugins目录下的NodeJS文件夹删除，将压缩包直接放在plugins目录下，idea可以直接解压插件压缩包：结果还是不行：原来是插件与idea的版本不兼容，需要适配。查看idea版本：Help–&gt;about这个版本对应着插件的COMPATIBILITY，只要idea版本介于插件的COMPATIBILITY范围内即可。符合要求的版本有几个，随机选择一个下载：直接Install plugin from disk ，加载压缩包，重启idea：终于出来了然后创建第一个应用：发现红框处无法获取版本，莫不是加载方式的锅？于是又尝试着直接将压缩包解压的文件夹放在plugins目录下，这次可以正常获取版本了。 这坑是真心多（逃最后总结一下这个插件安装流程：1.File -&gt; setting -&gt;Plugins-&gt;Browe repositories，搜索nodejs,下载2.若下载失败，去 官网下载对应插件压缩包，将压缩包解压，NodeJS文件夹直接放在idea安装目录下的plugins子目录下3.重启idea，就可以正常创建一定要注意的点：1.插件与idea版本的匹配2.Install plugin from disk加载压缩包在创建应用时无法正常获取express版本，最好直接解压放在idea安装目录的plugins下补充：后来在Mac上面重新安装了一次，没遇到上面的问题，看来正常情况下idea可下载的NodeJS插件应该是跟自身版本匹配的，当然真要是出了问题也可以按照上面步骤解决","categories":[{"name":"node","slug":"node","permalink":"https://github.com/lsfst/lsfst.github.io/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://github.com/lsfst/lsfst.github.io/tags/node/"}]},{"title":"一次mysql业务优化过程","slug":"数据库触发器优化","date":"2018-09-16T16:00:00.000Z","updated":"2019-07-12T03:25:27.426Z","comments":true,"path":"2018/09/17/数据库触发器优化/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/09/17/数据库触发器优化/","excerpt":"","text":"&emsp;&emsp;最近mysql数据库读写压力比较大，虽然配置了主从数据库，但还是需要进一步改善。原先业务中大量使用了mysql的触发器，对数据库性能有一定影响，所以要去掉部分触发器。####解决方案原先用户在前端修改信息时，会向后台发送请求，操作数据库进行读写，如果某些关键字段发生修改，就会触发触发器，在临时表插入临时记录。后台定时任务会定期查询记录表，完成业务处理后删除记录，比如说发送注册短信，远程控制设备等。js eval 代替触发器&emsp;&emsp;触发器的语法并不复杂，但有时候会遇到条件比较复杂的情况，比如说：123456789101112CREATE TRIGGER trig AFTER UPDATE ON tbUser FOR EACH ROW BEGIN DECLARE str VARCHAR(40)character set utf8; IF new.status != 0 THEN SET str = &quot;OK&quot;; ELSEIF new.status = 0 AND (old.age != new.age or old.sex != new.sex ) THEN SET str = &quot;BAD&quot;; END IF; INSERT INTO logs(log) values(str); END; &emsp;&emsp;触发这个触发器需要检查status，age，sex三个字段的值，如果放在后端代码中去检查，往往还需要先在数据库中查询一次修改前的值进行对比，这样绕一圈繁琐不说，还会浪费部分性能。除此之外，由于业务中这样的触发器有多个，全部改的话后端代码要修改很多，后期业务发生变更，也很麻烦。&emsp;&emsp;好在触发器的这种条件判断使用js的eval()方法是很容易做到的。eval()方法接收一个参数s，如果s不是字符串，则直接返回s。否则执行s语句。如果s语句执行结果是一个值，则返回此值，否则返回undefined。像上面那个触发器就可以改造成这样：12345let oldVal = &#123;name: &quot;张三&quot;, status: 0, age: 23, sex: &quot;男&quot;&#125;, newVal = &#123;name: &quot;张三&quot;, status: 1, age: 23, sex: &quot;男&quot;&#125;, logStr = &quot;&quot;;eval(&quot;if(newVal.status == 0)&#123;logStr = &apos;OK&apos;&#125; else if (newVal.status != 0 || (oldVal.age != newVal.age || oldVal.sex != newVal.sex))&#123;logStr = &apos;BAD&apos;&#125;&quot;);console.log(logStr); //-&gt;&apos;BAD&apos;&emsp;&emsp;当然因为eval太强大了，所以它只能在非严格模式中进行使用，在use strict中是不允许使用这个方法的。这样每个涉及到触发器的http请求都可以在前端统一进行判断，并在请求中带上相关标识，在后端AOP切面中进行处理。消息队列存储临时记录&emsp;&emsp;如果业务都在单机上，其实是可以用线程池处理的，Executers提供的固定线程池使用了一个无界队列LinkedBlockingQueue，缺点是受限于应用服务器的内存大小，队列长度不易太长，且缺乏持久化机制，比较适合处理简单的逻辑。与之相比，消息队列则更适合多机情况，更重要的是能提供持久化，方便控制和监察队列数量和消息消费速率。&emsp;&emsp;考虑到实际业务需求，还是使用redis队列更合适，单机redis可以支持10W的QPS，完全可以满足需求。使用redis队列&emsp;&emsp;Redis的列表使用双向链表实现，保存了头尾节点，在列表头尾两边插取元素都是非常快的，可以直接使用Redis的List实现消息队列，只需简单的两个指令lpush和rpop或者rpush和lpop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class RedisConsumer extends Thread &#123; private static Logger logger = LoggerFactory.getLogger( RedisConsumer.class ); private String customerName; private ListOperations listOperations; private static boolean stop = false; public RedisConsumer(String name,ListOperations listOperations) &#123; this.customerName = name; this.listOperations = listOperations; &#125; public void stopCounsume()&#123; stop = false; &#125; public void cousume() &#123; //使用brpop指令，在有元素时才返回，没有则阻塞直到超时返回null，可以减少不必要的连接浪费 Object message = listOperations.rightPop( RedisConst.QUEUE_NAME, RedisConst.BLOCK_TIME, TimeUnit.MILLISECONDS ); if ( message != null ) &#123; handle( message.toString() ); &#125; &#125; public void handle(String message) &#123; //... logger.info(customerName + &quot; 正在处理消息: &quot; + message); &#125; @Override public void run() &#123; while (!stop) &#123; try &#123; Thread.sleep( 100 ); &#125; catch ( InterruptedException e ) &#123; logger.info( &quot;sleep interrupted|&#123;&#125;&quot;,e.getMessage() ); &#125; cousume(); &#125; &#125;&#125;public class RedisConst &#123; public static String QUEUE_NAME = &quot;message:queue&quot; ; public static int BLOCK_TIME = 3000 ;&#125;redis发布订阅模式&emsp;&emsp;实际上redis本身也提供了的类似MQ的简单发布订阅模式，结合Spring使用起来非常简单，但是仔细看过文档后，发现这个功能还是有所不足。&emsp;&emsp;redis的发布订阅与主流的消息队列中间件比较：（1）主流的消息队列如RabbitMQ,ActiveMQ等支持多种消息协议，包括AMQP，MQTT，Stomp等，并且支持JMS规范，但Redis没有提供对这些协议的支持； （2）消息队列提供持久化功能，但Redis无法对消息持久化存储，一旦消息被发送，如果没有订阅者接收，那么消息就会丢失； （3）消息队列提供了消息传输保障(发布-接收确认和事务)，当客户端连接超时或事务回滚等情况发生时，消息会被重新发送给客户端，Redis没有提供消息传输保障。 &emsp;&emsp;其中最大的缺点是消息没有持久化，没有传输保障，无法保证客户端能对消息进行消费，所以这个方案也就只能pass了。","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://github.com/lsfst/lsfst.github.io/tags/redis/"},{"name":"mysql","slug":"mysql","permalink":"https://github.com/lsfst/lsfst.github.io/tags/mysql/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/lsfst/lsfst.github.io/tags/javascript/"}]},{"title":"Springboot 整合Spring Security 登录验证","slug":"SpringSecurity","date":"2018-06-20T16:00:00.000Z","updated":"2018-12-01T13:53:04.806Z","comments":true,"path":"2018/06/21/SpringSecurity/","link":"","permalink":"https://github.com/lsfst/lsfst.github.io/2018/06/21/SpringSecurity/","excerpt":"","text":"&emsp;&emsp;公司后台管理项目之前采用的是shiro做权限验证，前段时间花了点时间替换成了Spring Security，现在有时间将配置过程整理了一下。pom.xml引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;添加Spring Security配置类1234567891011@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .antMatchers(\"/css/**\", \"/js/**\",\"/fonts/**\").permitAll() .anyRequest().authenticated(); &#125;&#125;&emsp;&emsp;这样简单配置后，基本的验证功能就有了关于@EnableWebSecurity&emsp;&emsp;@EnableWebSecurity与WebSecurityConfigurerAdapter一起配合即可提供基于web的security，这俩是整个Spring Security配置的基础。EnableWebSecurity.class123456789@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;WebSecurityConfiguration.class, ObjectPostProcessorConfiguration.class, SpringWebMvcImportSelector.class&#125;)@EnableGlobalAuthentication@Configurationpublic @interface EnableWebSecurity &#123; boolean debug() default false;&#125;&emsp;&emsp;这里需要注意的是@EnableGlobalAuthentication：EnableGlobalAuthentication.class1234567@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;AuthenticationConfiguration.class&#125;)@Configurationpublic @interface EnableGlobalAuthentication &#123;&#125;&emsp;&emsp;在这个注解中，又导入了另外一个配置类AuthenticationConfiguration，AuthenticationConfiguration注册了AuthenticationManagerBuilder，其作用是对用户提交的用户名和密码进行验证，它是Spring Security账户验证的核心1234@Bean public AuthenticationManagerBuilder authenticationManagerBuilder(ObjectPostProcessor&lt;Object&gt; objectPostProcessor) &#123; return new AuthenticationManagerBuilder(objectPostProcessor); &#125;&emsp;&emsp;与HttpSecurity类似，AuthenticationManagerBuilder也是SecurityBuilder的一个子类。不同的是，HttpSecurity使用到的SecurityConfigurer基本上最终产生的都是一个过滤器，而AuthenticationManagerBuilder使用到SecurityConfiguer最终产生的都是AuthenticationManager的一个子类实例ProviderManager。ProviderManager类的创建是通过performBuild方法创建的。1234567891011121314151617protected ProviderManager performBuild() throws Exception &#123; if (!isConfigured()) &#123; logger.debug(\"No authenticationProviders and no parentAuthenticationManager defined. Returning null.\"); return null; &#125; //创建ProviderManager实例，用于管理验证提供者AuthenticationProvider ProviderManager providerManager = new ProviderManager(authenticationProviders, parentAuthenticationManager); if (eraseCredentials != null) &#123; providerManager.setEraseCredentialsAfterAuthentication(eraseCredentials); &#125; if (eventPublisher != null) &#123; providerManager.setAuthenticationEventPublisher(eventPublisher); &#125; providerManager = postProcess(providerManager); return providerManager;&#125;&emsp;&emsp;SpringSecurity的每一种方式都对应一个provider。如果需要联合使用多种验证方式，ProviderManager就可以帮助我们来管理这些provider，例如先用谁验证，后用谁验证，以及是否只要有一个provider验证成功就算用户已经成功验证等。AuthenticationProvider的创建：12345678910111213141516public InMemoryUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; inMemoryAuthentication() throws Exception &#123; return (InMemoryUserDetailsManagerConfigurer)this.apply(new InMemoryUserDetailsManagerConfigurer());&#125;public JdbcUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; jdbcAuthentication() throws Exception &#123; return (JdbcUserDetailsManagerConfigurer)this.apply(new JdbcUserDetailsManagerConfigurer());&#125;public &lt;T extends UserDetailsService&gt; DaoAuthenticationConfigurer&lt;AuthenticationManagerBuilder, T&gt; userDetailsService(T userDetailsService) throws Exception &#123; this.defaultUserDetailsService = userDetailsService; return (DaoAuthenticationConfigurer)this.apply(new DaoAuthenticationConfigurer(userDetailsService));&#125;public LdapAuthenticationProviderConfigurer&lt;AuthenticationManagerBuilder&gt; ldapAuthentication() throws Exception &#123; return (LdapAuthenticationProviderConfigurer)this.apply(new LdapAuthenticationProviderConfigurer());&#125;&emsp;&emsp;用户在登陆时，会被登陆验证拦截器AuthenticationProcessingFilter拦截，调用AuthenticationManager的实现，而AuthenticationManager会调用ProviderManager来获取用户验证信息，如果验证通过后会将用户的权限信息封装成一个User放到spring的全局缓存SecurityContextHolder中，以备后面访问资源时使用。登陆成功访问资源（即授权管理）时，会通过AbstractSecurityInterceptor拦截器拦截，其中会调用FilterInvocationSecurityMetadataSource的方法来获取被拦截url所需的全部权限，然后调用授权管理器AccessDecisionManager，这个授权管理器会通过spring的全局缓存SecurityContextHolder获取用户的权限信息，还会获取被拦截的url和被拦截url所需的全部权限，然后根据所配的策略（有：一票决定，一票否定，少数服从多数等），如果权限足够，则返回，权限不够则报错并调用权限不足页面。开启Spring Security自带注解&emsp;&emsp;Spring Security默认禁用注解，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为Bean1@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)12345@Bean @Override protected AuthenticationManager authenticationManager() throws Exception &#123; return super.authenticationManager(); &#125;JSR-250注解：@DenyAll 拒绝所有访问@RolesAllowed({“USER”, “ADMIN”}) @PermitAll 允许所有访问prePostEnabled注解：@PreAuthorize@PreAuthorize@PostAuthorize@PostAuthorizesecuredEnabled注解：@Secured其他配置基于UserDetailsService的认证服务&emsp;&emsp;spring security提供了多种认证方式(内存、JDBC、LDAP和自定义UserDetailService验证)，不管是哪一种验证方式，都是通过一个自动注入的AuthenticationManagerBuilder对象来完成的。这个类用于构建AuthenticationManager，其作用是对用户提交的用户名和密码进行验证定义SecurityUser用户实体类SecurityUser123456789101112public class User implements UserDetails, CredentialsContainer &#123; private static final long serialVersionUID = 410L; private String password; private final String username; private final Set&lt;GrantedAuthority&gt; authorities; private final boolean accountNonExpired; private final boolean accountNonLocked; private final boolean credentialsNonExpired; private final boolean enabled; ......&#125;&emsp;&emsp;项目中经常需要获取登录用户的角色信息，因此这里直接将role信息存进SecurityUser类中SecurityUser12345678910111213141516171819202122232425public class SecurityUser extends User &#123; private String role; public SecurityUser(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(username, password, authorities); &#125; public SecurityUser(String username, String password, boolean enabled, boolean accountNonExpired, boolean credentialsNonExpired, boolean accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities); &#125; public SecurityUser(String username, String password, String role, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(username, password, authorities); this.role = role; &#125; public String getRole() &#123; return this.role; &#125; public void setRole(String role) &#123; this.role = role; &#125;&#125;实现UserDetailsService账号验证SecurityUser1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Servicepublic class SecurityUserService implements UserDetailsService &#123; private static Logger logger= LoggerFactory.getLogger( SecurityUserService.class ); @Autowired EouCfrmUserService userService; @Autowired EouCfrmAuthorizationsService authorizationService; @Autowired EouAgentsService agentsService; @Override public SecurityUser loadUserByUsername( String username ) &#123; TbCfrmUser user=userService.selectByPrimaryKey( username ); if(user==null)&#123; logger.info( \"用户名不存在\" ); throw new BadCredentialsException(\"用户名不存在\"); &#125; List&lt;GrantedAuthority &gt; grantedAuthorities = new ArrayList&lt;GrantedAuthority&gt;(); List&lt;FrameAuthorization &gt; authorizations = authorizationService.selectAuthorizationByRole( user.getIdxRoleId_tbRole() ); GrantedAuthority grantedAuthority = new SimpleGrantedAuthority(\"ROLE_\"+user.getIdxRoleId_tbRole()); //1：此处将权限信息添加到 GrantedAuthority 对象中，在后面进行权限验证时会使用GrantedAuthority 对象。 grantedAuthorities.add(grantedAuthority); for(FrameAuthorization authorization:authorizations)&#123; //默认情况下，GrantedAuthority对象存储的是用户role信息，默认前缀ROLE_，可以按照实际情况自由配置 //此处将权限信息添加到 GrantedAuthority 对象中，在后面进行权限验证时会使用GrantedAuthority 对象。 grantedAuthority = new SimpleGrantedAuthority(authorization.getUrl()); grantedAuthorities.add(grantedAuthority); &#125; String role=user.getIdxRoleId_tbRole(); if(role.equals( \"admin\" ))&#123; &#125;else if(role.equals( \"agent\" ))&#123; try &#123; TbAgent agent=agentsService.selectAgentByAgentName( username ); idxOwnerId=agent.getIdxAgentId()+\".\"; &#125;catch ( Exception e)&#123; e.printStackTrace(); throw new BadCredentialsException(\"代理账号异常\"); &#125; &#125;else &#123; throw new BadCredentialsException(\"该账号暂无权限\"); &#125; return new SecurityUser(user.getKeyUserId(), user.getPassword(),user.getIdxRoleId_tbRole(), grantedAuthorities); &#125;&#125;&emsp;&emsp;这里有一个坑，用户在登录失败时，需要根据错误信息提示用户是账号密码错误。但在Spring Security中，默认情况下不管你是用户名不存在，密码错误，还是其他错误，都会转换成Bad credentials异常信息，而不是具体的错误。原因在于DaoAuthenticationProvider的父类AbstractUserDetailsAuthenticationProvider的authenticate方法中进行了处理：12345678910111213 try &#123; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (UsernameNotFoundException notFound) &#123; logger.debug(\"User '\" + username + \"' not found\"); if (hideUserNotFoundExceptions) &#123; throw new BadCredentialsException(messages.getMessage( \"AbstractUserDetailsAuthenticationProvider.badCredentials\", \"Bad credentials\")); &#125; else &#123; throw notFound; &#125; &#125; &emsp;&emsp;所以如果这里需要做自定义过滤验证，可以直接抛出BadCredentialsException。如果前端是JSP，可以通过 ${sessionScope.SPRING_SECURITY_LAST_EXCEPTION.message} 显示错误信息md5加密12345678910111213141516171819202122232425262728293031323334353637383940public class MyMessageDigestPasswordEncoder extends MessageDigestPasswordEncoder &#123; private static Logger logger= LoggerFactory.getLogger( MyMessageDigestPasswordEncoder.class ); public MyMessageDigestPasswordEncoder( String algorithm ) &#123; super( algorithm ); &#125; public MyMessageDigestPasswordEncoder( String algorithm, boolean encodeHashAsBase64 ) throws IllegalArgumentException &#123; super( algorithm, encodeHashAsBase64 ); &#125; //即使项目重启，页面刷新第一时间会在isPasswordValid方法中验证账号信息，验证成功后前往loginsuccesshandler public boolean isPasswordValid( String encPass, String rawPass, Object salt ) &#123; String pass1 = \"\" + encPass; String pass2 = MD5Utils.md5( rawPass ); //官方文档是通过encodePassword加盐加密，这个可以根据实际需求随意修改 logger.info( \"encPass:\" + encPass + \";rawPass:\" + rawPass + \"pass1:\" + pass1 + \";pass2:\" + pass2 ); boolean bool = false; if ( pass1.equals( pass2 ) ) &#123; bool = true; &#125; return bool; &#125; //自定义md5加密 public static String md5(String strObj) &#123; String resultString = null; try &#123; new String(strObj); MessageDigest ex = MessageDigest.getInstance(\"MD5\"); resultString = byteToString(ex.digest(strObj.getBytes())); &#125; catch (NoSuchAlgorithmException var3) &#123; var3.printStackTrace(); &#125; return resultString; &#125;&#125; 静态资源控制&emsp;&emsp;HttpSecurity的ignoring()与WebSecurity的permitAll()都可以控制静态资源。&emsp;&emsp;WebSecurityConfigurerAdapter提供了三个configure方法，分别提供对AuthenticationManagerBuilder，WebSecurity与HttpSecurity的配置，其中AuthenticationManagerBuilder进行账号认证配置。&emsp;&emsp;WebSecurity主要是跟web资源相关的配置，HttpSecurity则是对所有http请求进行管理，两者可以控制静态资源的权限，但本质的区别在于：HttpSecurity的ignoring()完全绕过了spring security的所有filter，相当于不走验证，比较适合配置前端相关的静态资源；HttpSecurity的permitAll()则没有绕过spring security，其中包含了登录的以及匿名的，会给没有登录的用户适配一个AnonymousAuthenticationToken，设置到SecurityContextHolder，方便后面的filter可以统一处理authentication。CSRF1234567891011121314151617public class CsrfSecurityRequestMatcher implements RequestMatcher &#123; private static Logger logger = LoggerFactory.getLogger( CsrfSecurityRequestMatcher.class ); private Pattern allowedMethods = Pattern.compile( \"^(GET|HEAD|TRACE|OPTIONS)$\" ); private RegexRequestMatcher unprotectedMatcher = new RegexRequestMatcher( \"^/api/.*\", null ); @Override public boolean matches( HttpServletRequest httpServletRequest ) &#123; String uri=httpServletRequest.getRequestURI(); if ( allowedMethods.matcher( httpServletRequest.getMethod() ).matches()) &#123; return false; &#125; return !unprotectedMatcher.matches( httpServletRequest ); &#125; &#125; &emsp;&emsp;开启CSRF后，页面所有表单提交都需要带上token，如果页面是jsp/thymeleaf模板可以将token存进通用的页面中123&lt;meta name=\"_csrf\" content=\"$&#123;_csrf.token&#125;\"/&gt;&lt;meta name=\"_csrf_header\" content=\"$&#123;_csrf.headerName&#125;\"/&gt; &emsp;&emsp;如果想偷懒的话，也可以直接在CsrfSecurityRequestMatcher中对相应接口放行，我就是这么做的(逃&emsp;&emsp;注意：开启csrf后注销需使用post表单提交logout自定义LoginSuccessHandler123456789101112131415public class LoginSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler &#123; private static Logger logger = LoggerFactory.getLogger( LoginSuccessHandler.class ); private static String defaultTargetUrl = \"/index\"; @Override public void onAuthenticationSuccess( HttpServletRequest request, HttpServletResponse response, Authentication authentication ) throws IOException, ServletException &#123; //获得授权后可得到用户信息 SecurityUser userDetails = ( SecurityUser ) authentication.getPrincipal(); logger.info( \"[\" + userDetails.getRole() + \"]|\" + userDetails.getUsername() + \"|[\" + IPUtils.getIpAddress( request ) + \"] login success\" ); request.getRequestDispatcher( defaultTargetUrl ).forward( request, response ); &#125;&#125; 自定义安全过滤器&emsp;&emsp;相对于Springboot大部分的傻瓜式配置来说，这一步算是稍微复杂点的。AbstractSecurityInterceptor是认证和授权的集成 ,没有继承和实现任何和过滤器相关的类，具体和过滤器有关的部分由其子类所实现。每一种受保护对象都拥有继承自AbstrachSecurityInterceptor的拦截器类。spring security 提供了两个具体实现类，MethodSecurityInterceptor 用于受保护的方法，FilterSecurityInterceptor 用于受保护的web 请求，spring security 默认的过滤器是FilterSecurityInterceptor。两者具体工作流程为：查找当前请求里分配的配置属性。把安全对象，当前的Authentication和配置属性,提交给AccessDecisionManager来进行以此认证决定。有可能在调用的过程中,对Authentication进行修改。允许安全对象进行处理（假设访问被允许了）。在调用返回的时候执行配置的AfterInvocationManager。如果调用引发异常,AfterInvocationManager将不会被调用。&emsp;&emsp;权限鉴定是由AccessDecisionManager 接口中的decide()方法负责的。decide() 方法需要接收一个受保护对象对应的configAttribute集合的。一个configAttribute可能只是一个简单的角色名称，具体将视AccessDecisionManager的实现者而定。由于我们需要自定义过滤器，所以需要重写AbstrachSecurityInterceptor的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 @Service public class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123; @Autowired public MyInvocationSecurityMetadataSourceService myInvocationSecurityMetadataSourceService; @Autowired public void setMyAccessDecisionManager( MyAccessDecisionManager myAccessDecisionManager ) &#123; super.setAccessDecisionManager( myAccessDecisionManager ); &#125; @Override public void init( FilterConfig filterConfig ) throws ServletException &#123;&#125; @Override public void doFilter( ServletRequest request, ServletResponse response, FilterChain chain ) throws IOException, ServletException &#123; FilterInvocation fi = new FilterInvocation(request, response, chain); invoke(fi); &#125; public void invoke( FilterInvocation fi ) throws IOException, ServletException &#123; //fi里面有一个被拦截的url //里面调用MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法获取fi对应的所有权限 //再调用MyAccessDecisionManager的decide方法来校验用户的权限是否足够 InterceptorStatusToken token = super.beforeInvocation( fi ); try &#123; //执行下一个拦截器 fi.getChain().doFilter( fi.getRequest(), fi.getResponse() ); &#125; finally &#123; super.afterInvocation( token, null ); &#125; &#125; @Override public void destroy() &#123;&#125; @Override public Class&lt; ? &gt; getSecureObjectClass() &#123; return FilterInvocation.class; &#125; @Override public SecurityMetadataSource obtainSecurityMetadataSource() &#123; return this.myInvocationSecurityMetadataSourceService; &#125;&#125; @Service public class MyInvocationSecurityMetadataSourceService implements FilterInvocationSecurityMetadataSource &#123; @Autowired public TbCfrmUserMapper cfrmUserMapper; private static Logger logger= LoggerFactory.getLogger( MyInvocationSecurityMetadataSourceService.class ); private static HashMap&lt;String, Collection&lt;ConfigAttribute&gt;&gt; map =null; /** * 加载权限表中所有权限 */ public void loadResourceDefine()&#123; logger.info( \"=================loadResourceDefine=================\" ); map = new HashMap(); Collection&lt;ConfigAttribute&gt; array; ConfigAttribute cfg; String role= SecurityUtils.getRole(); List&lt;FrameAuthorization &gt; authorizations = cfrmUserMapper.selectAuthorizationByRole(role); for(FrameAuthorization authorization : authorizations) &#123; cfg = new SecurityConfig(authorization.getUrl()); //此处添加的信息将会作为MyAccessDecisionManager类的decide的第三个参数。 array.add(cfg); //用权限的getUrl() 作为map的key，用ConfigAttribute的集合作为 value， map.put(authorization.getUrl(), array); &#125; &#125; //判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 @Override public Collection&lt; ConfigAttribute &gt; getAttributes( Object object ) throws IllegalArgumentException &#123; if(map ==null) loadResourceDefine(); //object 中包含用户请求的request 信息 HttpServletRequest request = ((FilterInvocation ) object).getHttpRequest(); AntPathRequestMatcher matcher; String resUrl; for( Iterator&lt;String&gt; iter = map.keySet().iterator(); iter.hasNext(); ) &#123; resUrl = iter.next(); matcher = new AntPathRequestMatcher(resUrl); if(matcher.matches(request)) &#123; return map.get(resUrl); &#125; &#125; return null; &#125; @Override public Collection&lt; ConfigAttribute &gt; getAllConfigAttributes() &#123; return null; &#125; @Override public boolean supports( Class&lt; ? &gt; aClass ) &#123; return true; &#125; &#125; //权限验证的核心管理器，重写decide方法可按照实际需求进行验证(比如实现投票器，多对一，一对多，一对一等)。 @Service public class MyAccessDecisionManager implements AccessDecisionManager &#123; Logger logger= LoggerFactory.getLogger( MyAccessDecisionManager.class ); //authentication 是SecurityUserService中循环添加到 GrantedAuthority 对象中的权限信息集合. //object 包含客户端发起的请求的requset信息，可转换为 HttpServletRequest request = ((FilterInvocation) object).getHttpRequest(); //configAttributes 为MyInvocationSecurityMetadataSource的getAttributes(Object object)这个方法返回的结果，此方法是为了判定用户请求的url 是否在权限表中，如果在权限表中，则返回给 decide 方法，用来判定用户是否有此权限。如果不在权限表中则放行。 //也即在loadResourceDefine必须对所有需要配置权限的url进行注册，未注册的url不会去检测权限 //在Authentication中则注册角色权限 @Override public void decide( Authentication authentication, Object o, Collection&lt; ConfigAttribute &gt; configAttributes ) throws AccessDeniedException, InsufficientAuthenticationException &#123; if(null== configAttributes || configAttributes.size() &lt;=0) &#123; return; &#125; ConfigAttribute c; String needRole; for( Iterator&lt;ConfigAttribute&gt; iter = configAttributes.iterator(); iter.hasNext(); ) &#123; c = iter.next(); needRole = c.getAttribute(); for(GrantedAuthority ga : authentication.getAuthorities()) &#123;//authentication 为在注释1 中循环添加到 GrantedAuthority 对象中的权限信息集合 if(needRole.trim().equals(ga.getAuthority())) &#123; return; &#125; &#125; &#125; logger.info( \"AccessDecisionManager decide:no right\" ); throw new AccessDeniedException(\"no right\"); &#125; //全部改为true @Override public boolean supports( ConfigAttribute configAttribute ) &#123; return true; &#125; @Override public boolean supports( Class&lt; ? &gt; aClass ) &#123; return true; &#125; &#125; &emsp;&emsp;注意：这里有个坑，由于项目采用Mybatis作为持久化框架,FilterInvocationSecurityMetadataSource中采用@Autowired注入mapper时可能会报错，建议在xml里面配置强制注入mapper。Basic认证&emsp;&emsp;如果项目提供的是restful服务，需要对请求进行basic认证，也非常简单123456789@Override protected void configure( HttpSecurity http ) throws Exception &#123; http.authorizeRequests(). requestMatchers( CorsUtils::isPreFlightRequest).permitAll(). //跨域设置：预请求放行 anyRequest().authenticated() .and() .csrf().disable() //禁用csrf .httpBasic(); &#125;principal获取用户信息1234567891011121314151617将获取登录用户信息的方法进行整理，便于之后使用public class SecurityUtils &#123; public static SecurityUser getSecurityUser() &#123; Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); return principal != null &amp;&amp; !principal.equals(\"anonymousUser\")?(SecurityUser)principal:null; &#125; public static String getUserName() &#123; SecurityUser user = getSecurityUser(); return user == null?\"\":user.getUsername(); &#125; public static String getRole() &#123; SecurityUser user = getSecurityUser(); return user == null?\"\":user.getRole(); &#125;&#125;收工最后完成的WebSecurityConfig配置类就是这样子了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public MyFilterSecurityInterceptor myFilterSecurityInterceptor()&#123; return new MyFilterSecurityInterceptor(); &#125; @Bean UserDetailsService SecurityUserService() &#123; //注册UserDetailsService 的bean return new SecurityUserService(); &#125; @Bean CsrfSecurityRequestMatcher CsrfSecurityRequestMatcher() &#123; //注册UserDetailsService 的bean return new CsrfSecurityRequestMatcher(); &#125; @Bean MyMessageDigestPasswordEncoder MyMessageDigestPasswordEncoder() &#123; //注册md5加密 return new MyMessageDigestPasswordEncoder( \"md5\" ); &#125; @Bean LoginSuccessHandler LoginSuccessHandler() &#123; //登录成功后可使用loginSuccessHandler()处理逻辑。 return new LoginSuccessHandler(); &#125; @Bean MyLoginUrlAuthenticationEntryPoint MyLoginUrlAuthenticationEntryPoint() &#123; return new MyLoginUrlAuthenticationEntryPoint(\"/login\"); &#125; @Bean @Override protected AuthenticationManager authenticationManager() throws Exception &#123; return super.authenticationManager(); &#125; @Override protected void configure( AuthenticationManagerBuilder auth ) throws Exception &#123; auth.userDetailsService( SecurityUserService() ).passwordEncoder( MyMessageDigestPasswordEncoder() ); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; //HttpSecurity优先级高于WebSecurity web.ignoring().antMatchers( \"/assets/**\" ); &#125; @Override protected void configure( HttpSecurity http ) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/login\" , \"/state/**\",\"/api/**\").permitAll() .antMatchers( \"/frame/**\" ).hasRole( \"admin\" ) //hasRole/hasAuthority本质上一样 .anyRequest().authenticated() .and() .formLogin() .loginPage( \"/login\" ) .loginProcessingUrl( \"/login\" ) // .successForwardUrl( \"/index\" ) //登录是post请求，成功后跳转至index页面，需要index也支持post .successHandler( LoginSuccessHandler() ) //配置successHandler后,successForwardUrl会失效，默认重定向路径\"/\" .failureUrl( \"/login\" ) .and() .csrf() // .disable() .requireCsrfProtectionMatcher( CsrfSecurityRequestMatcher() ) //配置csrf .and() .rememberMe() .tokenRepository( new InMemoryTokenRepositoryImpl() ) .tokenValiditySeconds( 1209600 )/*记住登录状态2周*/ .and() .logout() .logoutRequestMatcher( new AntPathRequestMatcher( \"/logout\", \"POST\" ) ) //开启csrf后注销需使用post表单提交 // .deleteCookies( \"remember-me\" ) // .deleteCookies( \"JSESSIONID\",\"remember-me\" ) .clearAuthentication( true ) .invalidateHttpSession( true ) .logoutSuccessUrl( \"/login\" ) .and() .sessionManagement() .invalidSessionUrl(\"/login\") .maximumSessions( 1 ) //设置最大登录数1，后面登录会踢掉当前用户 .expiredUrl( \"/login\" ); http.addFilterBefore( myFilterSecurityInterceptor(), FilterSecurityInterceptor.class ); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/lsfst/lsfst.github.io/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://github.com/lsfst/lsfst.github.io/tags/Springboot/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://github.com/lsfst/lsfst.github.io/tags/Spring-Security/"}]}]}